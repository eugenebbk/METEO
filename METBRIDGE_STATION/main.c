#define F_CPU 64000000UL   // задаём тактовую частоту равной 64 МГц
#define F_TWI 400000UL	   // задаём тактовую частоту TWI равную 400кГц (400кГц - максимум для twi)
#include <avr/io.h>		   //включаем директиву определений портов
#include <avr/interrupt.h> //включаем директиву определений адресов прерываний
#include <util/delay.h>	   //включаем директиву с функциями задержки
#include <math.h>		   //включаем директиву с математическими функциями
#include <stdio.h>		   //включаем директиву ввода-вывода стандартной библиотеки языка Си
#include <stdlib.h>		   //включаем директиву с функциями преобразования типов и другие функции Си
#include <avr/eeprom.h>	   //включаем директиву для работы с памятью eeprom
#include <avr/pgmspace.h>  //включаем директиву для работы с памятью flash (для задания массива, размещённого в памяти flash)

//---------------------------------------------------------------------------------------------------------------------------- Переменные (начало)
const uint8_t twi_address_BME280 = 0x76;	 // значение twi-адреса датчика BME280
const uint8_t USART_address = 0x24;			 // значение собственного USART-адреса метеоблока М1
const uint8_t program_version_number = 0x01; // номер версии прошивки метеоблока М1
const uint8_t program_variant_number = 0x02; // номер варианта версии прошивки метеоблока М1
uint8_t status_prog;						 // статус прошивки метеоблока М1
uint16_t serial_number = 0;					 // серийный номер метеоблока М1
uint8_t USART_speed = 2;					 // значение кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с, "2" - 19,2 кбит/с, "3" - 38,4 кбит/с)
uint16_t crc16;								 // объявление переменной для хранения результата вычисления crc16

uint16_t DIG_T1; // переменная для хранения данных калибровки температуры T1 датчика BME280
int16_t DIG_T2;	 // переменная для хранения данных калибровки температуры T2 датчика BME280
int16_t DIG_T3;	 // переменная для хранения данных калибровки температуры T3 датчика BME280
uint16_t DIG_P1; // переменная для хранения данных калибровки давления P1 датчика BME280
int16_t DIG_P2;	 // переменная для хранения данных калибровки давления P2 датчика BME280
int16_t DIG_P3;	 // переменная для хранения данных калибровки давления P3 датчика BME280
int16_t DIG_P4;	 // переменная для хранения данных калибровки давления P4 датчика BME280
int16_t DIG_P5;	 // переменная для хранения данных калибровки давления P5 датчика BME280
int16_t DIG_P6;	 // переменная для хранения данных калибровки давления P6 датчика BME280
int16_t DIG_P7;	 // переменная для хранения данных калибровки давления P7 датчика BME280
int16_t DIG_P8;	 // переменная для хранения данных калибровки давления P8 датчика BME280
int16_t DIG_P9;	 // переменная для хранения данных калибровки давления P9 датчика BME280
uint8_t DIG_H1;	 // переменная для хранения данных калибровки влажности H1 датчика BME280
int16_t DIG_H2;	 // переменная для хранения данных калибровки влажности H2 датчика BME280
uint8_t DIG_H3;	 // переменная для хранения данных калибровки влажности H3 датчика BME280
int16_t DIG_H4;	 // переменная для хранения данных калибровки влажности H4 датчика BME280
int16_t DIG_H5;	 // переменная для хранения данных калибровки влажности H5 датчика BME280
int8_t DIG_H6;	 // переменная для хранения данных калибровки влажности H6 датчика BME280

uint8_t BME280_compensate_T_znak; // переменная для хранения знака скомпенсированной температуры ("1"- отрицательная, "0"- положительная температура)
uint8_t BME280_compensate_T1;	  // переменная для хранения 1-го байта скомпенсированной температуры (десятки градусов Цельсия)
uint8_t BME280_compensate_T2;	  // переменная для хранения 2-го байта скомпенсированной температуры (единицы градуса Цельсия)
uint8_t BME280_compensate_T3;	  // переменная для хранения 3-го байта скомпенсированной температуры (десятые доли градуса Цельсия)
int16_t BME280_T_full;			  // переменная для хранения полного значения температуры модуля BME280 как числа со знаком (в десятых долях градуса Цельсия)
uint8_t BME280_compensate_P1;	  // переменная для хранения 1-го байта скомпенсированного давления (сотни мм рт. ст.)
uint8_t BME280_compensate_P2;	  // переменная для хранения 2-го байта скомпенсированного давления (десятки мм рт. ст.)
uint8_t BME280_compensate_P3;	  // переменная для хранения 3-го байта скомпенсированного давления (единицы мм рт. ст.)
uint8_t BME280_compensate_P4;	  // переменная для хранения 4-го байта скомпенсированного давления (десятые доли мм рт. ст.)
uint16_t BME280_P_full;			  // переменная для хранения полного значения давления модуля BME280 как числа без знака (в десятых долях мм рт. ст.)
uint8_t BME280_compensate_H1;	  // переменная для хранения 1-го байта скомпенсированной влажности (десятки процентов относительной влажности)
uint8_t BME280_compensate_H2;	  // переменная для хранения 2-го байта скомпенсированной влажности (единицы процентов относительной влажности)
uint8_t BME280_compensate_H3;	  // переменная для хранения 3-го байта скомпенсированной влажности (десятые доли процентов относительной влажности)
uint16_t BME280_H_full;			  // переменная для хранения полного значения влажности модуля BME280 как числа без знака (десятые доли процентов относительной влажности)
int16_t DS18B20_T_full;			  // переменная для хранения полного значения температуры датчика DS18B20 как числа со знаком (в десятых долях градуса Цельсия)

uint8_t Mas_BME280_KALIBR[32]; // объявление массива Mas_BME280_KALIBR для хранения принятых данных калибровки датчика BME280
uint8_t Mas_BME280_TPH[8];	   // объявление массива Mas_BME280_TPH для хранения принятых данных температуры, давления и влажности датчика BME280
uint8_t Mas_DS18B20[9];		   // объявление массива Mas_DS18B20 для хранения принятых данных датчика DS18B20
uint8_t Mas_meteo[21];		   // объявление массива Mas_meteo для передачи метеоданных на ПК
uint8_t Mas_crc16[117];		   // объявление массива Mas_crc16  для подсчёта значения crc16, где 1-й элемент массива указывает на число актуальных элементов массива
uint8_t counter_buffer;		   // глобальная переменная для хранения счётчика принятых/переданных байтов

uint16_t tek_menu = 1000; // объявление переменной для хранения текущего пункта меню
uint16_t vyp_menu = 0;	  // объявление переменной для хранения номера текущего пункта меню для выполнения

double Vx;	 // объявление переменной для хранения результата измерения скорости ветра по оси Х в дм/c
double Vy;	 // объявление переменной для хранения результата измерения скорости ветра по оси У в дм/c
double V;	 // объявление переменной для хранения результата измерения результирующей скорости ветра в дм/c
double Napr; // объявление переменной для хранения направления ветра в градусах
double Vprevious = 0;
uint16_t Mas_previousPD[4];

double const Cos_a = 0.625; // объявление константы для задания косинуса угла между вектором скорости ультразвука и вектором скорости ветра (a=51,3°)
double Cul = 3430;			// объявление константы для задания скорости ультразвука в воздухе по умолчанию в нормальных условиях (в дм/с)
double Ct;					// объявление переменной для хранения скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с)
double Cx;					// объявление переменной для хранения результата измерения скорости ультразвука (в дм/c) по оси Х
double Cy;					// объявление переменной для хранения результата измерения скорости ультразвука (в дм/c) по оси У

double Tob = 1866; // объявление переменной для задания начальной задержки прихода пачки импульсов по обеим осям (в десятых долях мкс)
double Tx;		   // объявление переменной для задания общей задержки прихода пачки импульсов по оси X без ветра (в десятых долях мм)
double Tx_kal;	   // объявление переменной для задания общей задержки прихода пачки импульсов по оси X после калибровки с ветром (в десятых долях мм)
double Ty;		   // объявление переменной для задания общей задержки прихода пачки импульсов по оси Y без ветра (в десятых долях мм)
double Ty_kal;	   // объявление переменной для задания общей задержки прихода пачки импульсов по оси Y после калибровки с ветром (в десятых долях мм)

int16_t dT = 88 * 64; // объявление переменной для задания начальной дополнительной задержки (во время работы таймера) прихода пачки импульсов по обеим осям (в тактах микроконтроллера)
int16_t dTx;		  // объявление переменной для задания дополнительной задержки (во время работы таймера) прихода пачки импульсов по оси X (в тактах микроконтроллера)
int16_t dTy;		  // объявление переменной для задания дополнительной задержки (во время работы таймера) прихода пачки импульсов по оси Y (в тактах микроконтроллера)

double S = 931; // объявление переменной для задания начальной длины пути ультразвука между датчиками (в десятых долях мм)
double Sx_kal;	// объявление переменной для задания длины пути ультразвука между датчиками по оси X после калибровки с ветром (в десятых долях мм)
double Sy_kal;	// объявление переменной для задания длины пути ультразвука между датчиками по оси Y после калибровки с ветром (в десятых долях мм)

double Tst_low;	 // объявление переменной для задания точки нижнего значения температуры эталона (в десятых долях градуса Цельсия)
double Tst_high; // объявление переменной для задания точки верхнего значения температуры эталона (в десятых долях градуса Цельсия)
double Tm_low;	 // объявление переменной для задания точки нижнего значения температуры метеоблока (в десятых долях градуса Цельсия)
double Tm_high;	 // объявление переменной для задания точки верхнего значения температуры метеоблока (в десятых долях градуса Цельсия)
double Th_low;	 // объявление переменной для задания точки нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия)
double Th_high;	 // объявление переменной для задания точки верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия)
int16_t Th_on;	 // объявление переменной для задания значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия)

double Hst_low;	 // объявление переменной для задания точки нижнего значения влажности эталона (в десятых долях процента)
double Hst_high; // объявление переменной для задания точки верхнего значения влажности эталона (в десятых долях процента)
double Hm_low;	 // объявление переменной для задания точки нижнего значения влажности метеоблока (в десятых долях процента)
double Hm_high;	 // объявление переменной для задания точки верхнего значения влажности метеоблока (в десятых долях процента)

double Pst_low;	 // объявление переменной для задания точки нижнего значения давления эталона (в десятых долях мм ртутного столба)
double Pst_high; // объявление переменной для задания точки верхнего значения давления эталона (в десятых долях мм ртутного столба)
double Pm_low;	 // объявление переменной для задания точки нижнего значения давления метеоблока (в десятых долях мм ртутного столба)
double Pm_high;	 // объявление переменной для задания точки верхнего значения давления метеоблока (в десятых долях мм ртутного столба)

double TPH_temp; // объявление вспомогательной переменной для промежуточной обработки данных температуры, давления и влажности

int16_t dT_k_null = 0; // объявление переменной для хранения начальной разницы времени прохождения сигнала по обеим осям (в тактах микроконтроллера)
int16_t dT_k0_k1_null; // объявление переменной для хранения разницы времени прохождения сигнала в канале 0 и канале 1 при калибровке без ветра (в тактах микроконтроллера)
int16_t dT_k2_k3_null; // объявление переменной для хранения разницы времени прохождения сигнала в канале 2 и канале 3 при калибровке без ветра (в тактах микроконтроллера)

int16_t dT_k0_sred; // объявление переменной для хранения среднего интервала времени прохождения сигнала в канале 0 (в тактах микроконтроллера)
int16_t dT_k2_sred; // объявление переменной для хранения среднего интервала времени прохождения сигнала в канале 2 (в тактах микроконтроллера)
int16_t dT_k0_k1;	// объявление переменной для хранения разницы времени прохождения сигнала в канале 0 и канале 1 (в тактах микроконтроллера)
int16_t dT_k2_k3;	// объявление переменной для хранения разницы времени прохождения сигнала в канале 2 и канале 3 (в тактах микроконтроллера)

int16_t Mas_timer_integral_X[2][10]; // объявление двумерного массива Mas_timer_integral_X для хранения 10-ти значений dT_k0_sred и dT_k0_k1 измерений по оси X
int16_t Mas_timer_integral_Y[2][10]; // объявление двумерного массива Mas_timer_integral_Y для хранения 10-ти значений dT_k2_sred и dT_k2_k3 измерений по оси Y

uint8_t Mas_data_PD[16];			 // объявление массива Mas_data_PD для передачи данных в цифровой потенциометр
uint8_t Mas_basedPD[8];				 // объявление массива Mas_PD для установки потенциометра при работе с выбранным каналом
uint8_t Mas_PD_25mps_increment = 15; // повышение ку на 15 при ветрах свыше 20 метров в секунду
uint8_t Mas_PD_30mps_increment = 35; // повышение ку на 35 при ветрах свыше 32 метров в секунду

uint8_t status_kal_KU;	  // объявление переменной для хранения статуса калибровки усиления
uint8_t status_kal_K0;	  // объявление переменной для хранения статуса калибровки без ветра
uint8_t status_kal_X;	  // объявление переменной для хранения статуса калибровки с ветром по оси X
uint8_t status_kal_Y;	  // объявление переменной для хранения статуса калибровки с ветром по оси Y
uint8_t status_kal_T;	  // объявление переменной для хранения статуса калибровки температуры и температуры подогрева метеоблока
uint8_t status_kal_Th_on; // объявление переменной для хранения статуса температуры включения подогрева метеоблока
uint8_t status_kal_H;	  // объявление переменной для хранения статуса калибровки влажности метеоблока
uint8_t status_kal_P;	  // объявление переменной для хранения статуса калибровки давления метеоблока

uint16_t Mas_sred_amplitude[4]; // объявление глобального массива для хранения средних амплитуд для 4-х каналов

uint8_t temp = 0; // объявление переменной temp для хранения индекса текущего элемента массива
uint8_t znak;	  // объявление переменной для задания знака числа

uint8_t KU = 0; // объявление переменной для задания общего коэффициента  усиления каналов (значение не должно быть более 63)

int16_t Mas_timer_temp[4][104];		// объявление двумерного массива Mas_timer для хранения N_point_sbor_dannyh=96 временных значений 16-битного таймера для каждого канала
uint8_t Mas_amplitude_temp[4][104]; // объявление двумерного массива Mas_amplituda для хранения N_point_sbor_dannyh=96 временных значений амплитуды для каждого канала

uint8_t ADC_virtual_null;			   // объявление переменной для хранения значения виртального нуля АЦП (в 8-ми разрядном коде)
uint8_t ADC_porog = 50;				   // объявление переменной для хранения значения порогового значения АЦП (в 8-ми разрядном коде)
uint8_t ADC_amplitude_kalibr = 150;	   // объявление переменной для задания значения установки амплитуды АЦП (в 8-ми разрядном коде) при калибровке усиления
uint8_t N_operativ = 14;			   // объявление переменной для задания количества точек оперативных массивов (по умолчанию 14 точек)
uint8_t Ns_operativ = 8;			   // объявление переменной для задания количества точек до порогового значения АЦП из количества точек оперативных массивов N_operativ (по умолчанию 4 точки)
int16_t Mas_timer_operativ[4][14];	   // объявление двумерного массива Mas_timer_operativ для хранения 14-ти временных значений оперативной выборки 16-битного таймера для каждого канала
uint8_t Mas_amplitude_operativ[4][14]; // объявление двумерного массива массива Mas_amplitude_operativ для хранения 14-ти временных значений оперативной выборки амплитуды для каждого канала
// uint8_t Mas_tab_level[4]; //объявление массива Mas_tab_level для хранения номера используемого уровня для каждого канала
int16_t Mas_timer_null[4];		// объявление массива Mas_timer_null для хранения теоретически расчитанного времени пересечения нуля для каждого канала
int8_t Mas_timer_null_point[4]; // объявление массива Mas_timer_null_point для хранения порядкового номера точки теоретически расчитанного времени пересечения нуля для каждого канала

uint8_t Mas_N_fix[4]; // объявление двумерного массива Mas_N_fix для хранения фиксированного номера точки для каждого канала
// uint16_t Mas_amplitude_point[4][56]; //объявление двумерного массива Mas_amplitude_point для хранения N_point_sbor_dannyh=3 точек амплитуды для каждого канала
uint8_t N_prohodov = 12;	  // объявление переменной для задания количества проходов (один проход - это 4 измерения времени, так как всего 4 канала)
uint8_t dN_prohodov = 4;	  // объявление переменной для задания количества  неучтённых проходов при вычислении с ипользованием функции "люкс"
int16_t Mas_timer[4][16];	  // объявление двумерного массива Mas_timer для хранения N_prohodov=16 значений 16-битного таймера для каждого канала
int16_t Mas_amplitude[4][16]; // объявление двумерного массива Mas_amplitude для хранения N_prohodov=16 значений 8-битного АЦП для каждого канала
// int8_t Mas_nomer_amplitude[4][32]; //объявление двумерного массива Mas_nomer_amplitude для хранения N_prohodov=16 значений номеров 8-битного АЦП для каждого канала

int16_t Mas_timer_sred[4];			  // объявление массива Mas_timer_sred[] для хранения средних значений времени соответствующего канала
uint16_t Mas_timer_min_max[4][2];	  // объявление двумерного массива Mas_timer_min_max[][] для хранения минимального и максимального значения времени соответствующего канала
uint16_t Mas_amplitude_min_max[4][2]; // объявление двумерного массива Mas_amplitude_min_max[][] для хранения минимального и максимального значения амплитуды соответствующего канала
uint32_t Mas_timer_prived[4];		  // объявление массива Mas_prived[] для хранения приведённых времён соответствующих каналов

uint8_t error;					  // объявление переменной error (значение "1" - присутствует ошибка №1, значение "0" - отсутствует)
uint8_t Sum_error;				  // объявление локальной переменной Sum_error для подсчёта количества ошибок "error" в полном цикле измерения
uint8_t Status_error_anemometr;	  // объявление переменной статуса ошибки анемометра (значения "1"-"4" - присутствуют ошибки, значение "0" - отсутствует)
uint8_t Status_error_BME280 = 0;  // объявление переменной статуса ошибки связи с модулем BME280 (значение "1" - присутствует статус ошибки, значение "0" - отсутствует)
uint8_t Status_error_DS18B20 = 0; // объявление переменной статуса ошибки связи с датчиком DS18B20 (значение "1" - присутствует статус ошибки, значение "0" - отсутствует)
uint8_t Status_error_USART = 0;	  // объявление переменной статуса ошибки модуля USART (значение "1" - присутствует статус ошибки, значение "0" - отсутствует)

uint8_t nomer_kanala; // объявление переменной nomer_kanala для хранения индекса текущего номера канала (всего 4 канала для 2-х пар приёмопередатчиков)

uint8_t Marker_button = 0; // объявление переменной Marker_button (значение "0" - с момента включения анемометра не была нажата кнопка №2 (с панели подключаемого LCD-модуля), значение "1" - да))

uint16_t INCREMENT_FOR_OVERFLOWED_TIMER_VALUES = 2000;
//---------------------------------------------------------------------------------------------------------------------------- Переменные (конец)

//---------------------------------------------------------------------------------------------------------------------------- Директивы (начало)
#define nazata_knopka_1 (!(PORTE_IN & (1 << 2)))	 // описание условия нажатой кнопки №1
#define nazata_knopka_2 (!(PORTD_IN & (1 << 7)))	 // описание условия нажатой кнопки №2
#define nazata_knopka_3 (!(PORTD_IN & (1 << 6)))	 // описание условия нажатой кнопки №3
#define Comparator_v_minuse (!(PORTA_IN & (1 << 2))) // описание условия присутствия лог."0" на входе компаратора

#define Nagrevatel_OFF (PORTA_OUT |= 0b00000001)	  // отключение нагревателя
#define Nagrevatel_ON (PORTA_OUT &= 0b11111110)		  // включение нагревателя
#define Status_Nagrevatel_ON (!(PORTA_IN & (1 << 0))) // описание условия включённого нагревателя

#define e1 PORTD_OUT |= 0b00100000	// установка линии E в 1
#define e0 PORTD_OUT &= 0b11011111	// установка линии E в 0
#define rs1 PORTD_OUT |= 0b00010000 // установка линии RS в 1 (данные)
#define rs0 PORTD_OUT &= 0b11101111 // установка линии RS в 0 (команда)

#define A0_ON PORTB_OUT |= 0b00001000  // установка лог."1" на линии A0
#define A0_OFF PORTB_OUT &= 0b11110111 // установка лог."0" на линии A0
#define A1_ON PORTB_OUT |= 0b00000100  // установка лог."1" на линии A1
#define A1_OFF PORTB_OUT &= 0b11111011 // установка лог."0" на линии A1
#define EN_ON PORTC_OUT |= 0b00000001  // установка лог."1" на линии EN
#define EN_OFF PORTC_OUT &= 0b11111110 // установка лог."0" на линии EN

#define Comparator_ON (PORTA_INT0MASK |= 0b00000100, PORTA_INTCTRL |= 0b00000011)  // присвоение выводу PA2 прерывания INT0 порта A и приоритета высокого уровня
#define Comparator_OFF (PORTA_INT0MASK &= 0b11111011, PORTA_INTCTRL &= 0b11111100) // запрет выводу PA2 прерывания INT0 порта A

#define Timer_ON (TCC0_CTRLA = TC_CLKSEL_DIV1_gc, TCC0_INTCTRLA = TC_OVFINTLVL_HI_gc)  // включение таймера-счётчика без деления тактовой частоты, разрешение прерывания высокого уровня приоритета по переполнению таймера-счётчика
#define Timer_OFF (TCC0_CTRLA = TC_CLKSEL_OFF_gc, TCC0_INTCTRLA = TC_OVFINTLVL_OFF_gc) // запрет прерываний и отключение таймера-счётчика

#define Timer_heating_control_ON (TCC1_CTRLA = TC_CLKSEL_DIV1024_gc, TCC1_INTCTRLA = TC_OVFINTLVL_LO_gc) // включение таймера-счётчика управления подогревом с делением тактовой частоты, разрешение прерывания низкого уровня приоритета по переполнению таймера-счётчика
#define Timer_heating_control_OFF (TCC1_CTRLA = TC_CLKSEL_OFF_gc, TCC1_INTCTRLA = TC_OVFINTLVL_OFF_gc)	 // выключение таймера-счётчика управления подогревом, запрет прерывания по переполнению таймера-счётчика

#define twi_master_ON (TWIE_MASTER_CTRLA = (TWI_MASTER_INTLVL_MED_gc) | (1 << TWI_MASTER_ENABLE_bp)) // установка среднего приоритета прерываний ведущего модуля twi, разрешение работы ведущего модуля twi
#define twi_master_OFF (TWIE_MASTER_CTRLA &= (0 << TWI_MASTER_ENABLE_bp))							 // установка запрета прерываний ведущего модуля twi,//запрет работы ведущего модуля twi

#define twi_master_bit_NACK (TWIE_MASTER_CTRLC = (1 << TWI_MASTER_ACKACT_bp) | (TWI_MASTER_CMD_RECVTRANS_gc)) // приём байта данных ведущим модулем twi без бита подтверждения
#define twi_master_bit_ACK (TWIE_MASTER_CTRLC = (0 << TWI_MASTER_ACKACT_bp) | (TWI_MASTER_CMD_RECVTRANS_gc))  // приём байта данных ведущим модуля twi с битом подтверждением
#define twi_master_START (TWIE_MASTER_CTRLC = (TWI_MASTER_CMD_REPSTART_gc))									  // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi
#define twi_master_STOP (TWIE_MASTER_CTRLC = (TWI_MASTER_CMD_STOP_gc))										  // формирование состояния "СТОП" модулем twi
#define twi_master_IDLE (TWIE_MASTER_STATUS = (TWI_MASTER_BUSSTATE_IDLE_gc))								  // формирование состояния "IDLE" (шина свободна) модулем twi

#define DS18B20_out_0 (PORTE_DIR |= 0b00001000, PORTE_OUT &= 0b11110111) // конфигурирование линии PE3 порта E как выход и установка лог."0"
#define DS18B20_out_1 (PORTE_DIR |= 0b00001000, PORTE_OUT |= 0b00001000) // конфигурирование линии PE3 порта E как выход и установка лог."1"
#define DS18B20_input (PORTE_DIR &= 0b11110111)							 // конфигурирование линии PE3 порта E как вход
#define DS18B20_read_0 (!(PORTE_IN & (1 << 3)))							 // условие присутствия лог."0" на линии PE3 порта E

#define interrupt_OFF (CPU_SREG &= (0 << CPU_I_bp));									// глобальный запрет прерываний
#define interrupt_ON (CPU_SREG = (1 << CPU_I_bp));										// глобальное разрешение прерываний
#define interrupt_button_OFF (PORTE_INTCTRL &= 0b11111100, PORTD_INTCTRL &= 0b11110000) // запрет прерываний по нажатию кнопок
#define interrupt_button_ON (PORTE_INTCTRL |= 0b00000001, PORTD_INTCTRL |= 0b00000101)	// разрешение прерываний по нажатию кнопок

#define RTC_OFF (RTC_INTCTRL = RTC_COMPINTLVL_OFF_gc) // запрет прерывания счетчика реального времени RTC по совпадению
#define RTC_ON (RTC_INTCTRL = RTC_COMPINTLVL_LO_gc)	  // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
//---------------------------------------------------------------------------------------------------------------------------- Директивы (конец)

//---------------------------------------------------------------------------------------------------------------------------- Функции (начало)
// —————————————
void oscPLL_ini(void) // функция инициализации системной частоты PLL (64МГц)
{
	OSC_XOSCCTRL = (OSC_FRQRANGE_12TO16_gc) | (OSC_XOSCSEL_XTAL_16KCLK_gc);																						// настройка частотного диапазона кварцевого генератора частоты (12-16 МГц) и времени его запуска (16 тыс. тактов)
	OSC_PLLCTRL = (OSC_PLLSRC_XOSC_gc) | (0 << OSC_PLLFAC4_bp) | (0 << OSC_PLLFAC3_bp) | (1 << OSC_PLLFAC2_bp) | (0 << OSC_PLLFAC1_bp) | (0 << OSC_PLLFAC0_bp); // выбор внешнего источника синхронизации для блока PLL и коэффициента умножения частоты равным 4
	OSC_CTRL = (1 << OSC_XOSCEN_bp);																															// разрешаем работу кварцевого резонатора
	while (!(OSC_STATUS & (1 << OSC_XOSCRDY_bp)))
		;							 // ожидание готовности кварцевого генератора
	OSC_CTRL |= (1 << OSC_PLLEN_bp); // разрешаем работу блока PLL (не затрагивая бит XOSCRDY разрешения работы кварцевого резонатора)
	while (!(OSC_STATUS & (1 << OSC_PLLRDY_bp)))
		; // ожидание готовности блока PLL
	////OSC.CTRL = OSC.CTRL & 0xFE;       // отключение системной синхронизации от внутреннего RC-генератора частотой 2 МГц
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_PSCTRL = (CLK_PSADIV_1_gc) | (CLK_PSBCDIV_1_1_gc); // коэффициент предделителя A системной синхронизации задаём равным 1, предделителя B=1 и предделителя C=1
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_CTRL = CLK_SCLKSEL_PLL_gc;						   // выбор блока PLL для системной синхронизации
}
// —————————————

// —————————————
void osc16MHz_ini(void) // функция инициализации системной частоты 16МГц
{
	OSC_XOSCCTRL = (OSC_FRQRANGE_12TO16_gc) | (OSC_XOSCSEL_XTAL_16KCLK_gc); // настройка частотного диапазона кварцевого генератора частоты (12-16 МГц) и времени его запуска (16 тыс. тактов)
	// OSC_PLLCTRL =(OSC_PLLSRC_XOSC_gc)|(0<<OSC_PLLFAC4_bp)|(1<<OSC_PLLFAC3_bp)|(0<<OSC_PLLFAC2_bp)|(0<<OSC_PLLFAC1_bp)|(0<<OSC_PLLFAC0_bp); //выбор внешнего источника синхронизации для блока PLL и коэффициента умножения частоты равным
	OSC_CTRL = (1 << OSC_XOSCEN_bp); // разрешаем работу внешнего генератора
	while (!(OSC_STATUS & (1 << OSC_XOSCRDY_bp)))
		; // ожидание готовности внешнего генератора
	// CCP =0xD8; //разрешение записи в защищённый регистр
	// CLK_RTCCTRL =(CLK_RTCSRC_RCOSC_gc)|(1<<CLK_RTCEN_bp); //выбор внутренего генератора для счётика реального времени (RTC) и включение RTC
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_PSCTRL = (CLK_PSADIV_1_gc) | (CLK_PSBCDIV_4_1_gc); // коэффициент предделителя A системной синхронизации задаём равным 1, предделителя B=4 и предделителя C=1
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_CTRL = CLK_SCLKSEL_XOSC_gc;						   // выбор внешнего генератора для системной синхронизации
}
// —————————————

// —————————————
void osc32MHz_ini(void) // функция инициализации системной частоты 32МГц
{
	// OSC_CTRL =OSC_RC32MEN_bm;//разрешаем работу внутреннего генератора частоты 32MHz
	OSC_CTRL |= (1 << OSC_RC32MEN_bp); // разрешаем работу внутреннего генератора частоты 32MHz
	while (!(OSC_STATUS & (1 << OSC_RC32MRDY_bp)))
		; // ожидание готовности внутреннего генератора частоты 32MHz
	// CCP =0xD8; //разрешение записи в защищённый регистр
	// CLK_RTCCTRL =(CLK_RTCSRC_RCOSC_gc)|(1<<CLK_RTCEN_bp); //выбор внутренего генератора для счётика реального времени (RTC) и включение RTC
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_PSCTRL = (CLK_PSADIV_1_gc) | (CLK_PSBCDIV_1_1_gc); // коэффициент предделителя A системной синхронизации задаём равным 1, предделителя B=1 и предделителя C=1
	CCP = 0xD8;											   // разрешение записи в защищённый регистр
	CLK_CTRL = CLK_SCLKSEL_RC32M_gc;					   // выбор внутреннего генератора частоты 32MHz
	// CCP =0xD8; //разрешение записи в защищённый регистр
	// CLK_LOCK =(1<<CLK_LOCK_bp); //установка бита защиты системной синхронизации
	// OSC_DFLLCTRL = (1<<OSC_RC32MCREF_gp); //выбираем для синхронизации генератора частоты 32МГц внешний генератор частоты 32kГц
	// DFLLRC32M_CTRL = (1<<DFLL_ENABLE_bp); //выбираем для синхронизации генератора частоты 32МГц внешний генератор частоты 32kГц
}
// —————————————

// —————————————
void osc32kHz_RTC_ini(void) // функция включения внешнего генератора частоты 32kГц счётчика реального времени
{
	OSC_CTRL |= (1 << OSC_RC32KEN_bp); // разрешаем работу внутреннего тактового генератора частоты 32kГц
	while (!(OSC_STATUS & (1 << OSC_RC32KRDY_bp)))
		; // ожидание готовности внутреннего генератора частоты 32кHz
	// CLK_RTCCTRL |= (1<<CLK_RTCSRC1_bp)|(1<<CLK_RTCEN_bp); //выбор для счётчика реального времени внутреннего генератора частоты 1kГц
	CLK_RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm; // выбор источника синхронизации 1 кГЦ для счётчика реального времени от внутреннего генератора частоты 32kГц и включение RTC
	// RTC_CTRL |= (0<<RTC_PRESCALER2_bp)|(0<<RTC_PRESCALER1_bp)|(1<<RTC_PRESCALER0_bp);//деление частоты счетчика реального времени на 1024 что равно 32 Гц
	RTC_CTRL = RTC_PRESCALER_DIV1_gc; // деление частоты счетчика реального времени RTC на 1 (на выходе 1 кГц)
	RTC_CNT = 0;					  // обнуление RTC
	RTC_COMP = 2700;				  // запись константы в регистр сравнения (для отсчёта 2,7 секунд)
	// RTC_INTCTRL |= (0<<RTC_COMPINTLVL1_bp)|(1<<RTC_COMPINTLVL0_bp)|(0<<RTC_OVFINTLVL1_bp)|(0<<RTC_OVFINTLVL0_bp);//разрешение прерывание низкого уровня по совпадению
	RTC_INTCTRL = RTC_COMPINTLVL_LO_gc; // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
}
// ———————————

// —————————————
void port_ini(void) // функция инициализации портов
{
	PORTA_DIR &= 0b11111001;	 // конфигурируем линии порта A: PA1,PA2 - входы
	PORTA_PIN2CTRL = 0b00000000; // без подтягивающего резистора, обнаружение нарастающего и спадающего фронтов на входе PA2 порта A

	PORTA_DIR |= 0b11111001; // конфигурируем линии порта A: PA0, PA3-PA7 - выходы
	PORTA_OUT &= 0b00000111; // установка лог."0" на выходах PA3-PA5, PA6 и PA7 порта A порта A
	PORTA_OUT |= 0b00000001; // установка лог."1" на выходах PA0 порта A (отключение нагревателя)

	PORTB_DIR |= 0b00001111; // конфигурируем линии порта B: PB0-PB3 - выходы
	PORTB_OUT &= 0b11110000; // установка лог."0" на выходах PB0-PB3 порта B

	PORTC_DIR |= 0b00011111; // конфигурируем линии порта C: PC0-PC4 - выходы
	PORTC_OUT &= 0b11100000; // установка лог."0" на выходах PC0-PC3 и PC4 порта C

	PORTD_DIR &= 0b00111111;	 // конфигурируем линии PD6,PD7 порта D как входы
	PORTD_PIN6CTRL = 0b00011011; // подтяжка входа PD6 порта D к плюсу питания, обнаружение лог."0" на входе
	PORTD_PIN7CTRL = 0b00011011; // подтяжка входа PD7 порта D к плюсу питания, обнаружение лог."0" на входе
	PORTD_DIR |= 0b00111111;	 // конфигурируем линии порта D: PD0-PD5 - выходы
	PORTD_OUT &= 0b11000000;	 // установка лог."0" на выходах PD0-PD5 порта D

	PORTE_DIR &= 0b11111011;	 // конфигурируем линию PE2 порта E как вход
	PORTE_PIN2CTRL = 0b00011011; // подтяжка входа PE2 порта E к плюсу питания, обнаружение лог."0" на входе
	PORTE_DIR &= 0b11110111;	 // конфигурируем линию PE3 порта E как вход
	PORTE_PIN3CTRL = 0b00011000; // подтяжка входа PE3 порта E к плюсу питания
}
// —————————————

// —————————————
void interrupt_ini(void) // функция инициализации прерываний
{
	PORTE_INT0MASK |= 0b00000100; // конфигурируем вектор прерывания INT0 на вход PE2 порта E (кнопка 1)
	PORTE_INTCTRL |= 0b00000001;  // задаём низкий приоритет прерывания INT0 порта E

	PORTD_INT0MASK |= 0b10000000; // конфигурируем вектор прерывания INT0 на вход PD7 порта D (кнопка 2)
	PORTD_INTCTRL |= 0b00000001;  // задаём низкий приоритет прерывания INT0 порта D

	PORTD_INT1MASK |= 0b01000000; // конфигурируем вектор прерывания INT1 на вход PD6 порта D (кнопка 3)
	PORTD_INTCTRL |= 0b00000100;  // задаём низкий приоритет прерывания INT1 порта D

	CCP = 0xD8;																									  // разрешение записи в защищённый регистр
	PMIC_CTRL = (0 << PMIC_IVSEL_bp) | (1 << PMIC_HILVLEN_bp) | (1 << PMIC_MEDLVLEN_bp) | (1 << PMIC_LOLVLEN_bp); // разрешаем все виды прерываний и перемещаем векторы прерываний в сектор прикладной программы
	// PMIC_CTRL &= 0b10111111; //перемещаем векторы прерываний в сектор прикладной программы
	CPU_SREG = (1 << CPU_I_bp); // глобальное разрешение прерываний
	// CPU_SREG &= (0<<CPU_I_bp);//глобальный запрет прерываний
}
// ————————————

// ————————————
void twi_master_ini(void) // функция нициализации ведущего модуля twi
{
	TWIE_MASTER_BAUD = F_CPU / (2 * F_TWI) - 5; // рассчёт константы для задания требуемой тактовой частоты модуля twi (для F_TWI=400кГц значение BAUD равно 75)
	TWIE_CTRL = TWI_SDAHOLD_50NS_gc;			// время задержки сигнала на линии SDA по отношению к отрицательному фронту сигнала на линии SCL задать равным 50 нс.
	twi_master_ON;								// установка низкого приоритета прерываний ведущего модуля twi, разрешение работы ведущего модуля twi
}
// ————————————

// —————————————-
void ADC_Init(void) // функция иницилизации АЦП
{
	// ADCB_CAL = (0x0FFF & ((PRODSIGNATURES_ADCBCAL1 << 8) | PRODSIGNATURES_ADCBCAL0)); //запись сигнатурного числа калибровки
	// ADCA_CTRLB |= (0<<ADC_CONMODE_bp)|(0<<ADC_RESOLUTION1_bp)|(0<<ADC_RESOLUTION0_bp); //выбор знакового режима и разрядности 12 бит АЦП
	ADCA_CTRLB = ADC_RESOLUTION_8BIT_gc; // выбор разрядности 8 бит АЦП

	ADCA_REFCTRL = ADC_REFSEL_INT1V_gc;		 // внутренний ИОН 1В
	ADCA_PRESCALER = ADC_PRESCALER_DIV16_gc; // задание предделителя частоты равным 16 (допустимо ещё только предделение на 32 с незначительным улучшением точности, но с уменьшением быстродействия в 2 раза)

	ADCA_CH0_CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; // одиночный внешний входной сигнал в канале 0 АЦП
	ADCA_CH1_CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; // одиночный внешний входной сигнал в канале 1 АЦП
	ADCA_CH2_CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; // одиночный внешний входной сигнал в канале 2 АЦП
	ADCA_CH3_CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; // одиночный внешний входной сигнал в канале 3 АЦП

	ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc; // выбор входа ADC1 в канале 0 АЦП
	ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc; // выбор входа ADC1 в канале 1 АЦП
	ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc; // выбор входа ADC1 в канале 2 АЦП
	ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc; // выбор входа ADC1 в канале 3 АЦП

	ADCA_CTRLA |= (0 << ADC_FLUSH_bp) | (1 << ADC_ENABLE_bp); // разрешение работы АЦП
}
// —————————————-

// —————————————- -----------------------------------------------------------------------------------------------------------------------начало определений функций для работы с ЖКИ
void sendhalfbyte(unsigned char c) // функция передачи полубайта
{
	e1;						 // включаем линию Е
	_delay_us(50);			 // задержка 50 мкс
	PORTD_OUT &= 0b11110000; // стираем информацию на входах DB4-DB7, остальное не трогаем
	PORTD_OUT |= c;			 // установить биты	данных PC4-PC7 из переменной c
	_delay_us(1);			 // задержка 1 мкс (необходима при системной частоте PLL)
	e0;						 // выключаем линию Е
}
// —————————————-

// —————————————-
void sendbyte(unsigned char c, unsigned char mode) // функция передачи полного байта данных и режима (данные или команда)
{
	if (mode == 0)
		rs0; // если переменная mode равна 0, то установить линию RS в 0 (команда)
	else
		rs1;			  // если переменная mode равна 1, то установить линию RS в 1 (данные)
	unsigned char hc = 0; // вводим локальную переменную hc
	hc = c >> 4;		  // присвоить hc значение старшего полубайта переменной c
	sendhalfbyte(hc);	  // передать на дисплей старший полубайт данных
	sendhalfbyte(c);	  // передать на дисплей младший полубайт данных
}
// —————————————-

// —————————————-
void sendcharlcd(unsigned char c) // функция для передачи только данных
{
	sendbyte(c, 1); // передаём байт данных
	_delay_us(50);	// задержка 50 мкс//
}
// —————————————-

// —————————————-
void setpos(unsigned char x, unsigned y) // функция позиционирования символа
{
	char adress = 0;					  // вводим локальную переменную adress
	adress = (0x40 * y + x) | 0b10000000; // вычисление управляющего байта для символа на основе требуемой позиции строки x и столбца y
	sendbyte(adress, 0);				  // передача управляющего байта как команды позиционирования
}
// —————————————-

// —————————————-
void LCD_ini(void) // функция инициализации дисплея
{
	_delay_ms(15);			  // задержка 15 мс
	sendhalfbyte(0b00000011); // передадим в контроллер дисплея двоичное число 11 три раза, согласно даташиту
	_delay_ms(4);			  // задержка 4 мс
	sendhalfbyte(0b00000011); //...2-й раз
	_delay_us(100);			  // задержка 100 мкс
	sendhalfbyte(0b00000011); //...3-й раз
	_delay_ms(1);			  // задержка 1 мс
	sendhalfbyte(0b00000010); // передадим в контроллер дисплея двоичное число 10 согласно даташиту
	_delay_ms(1);			  // задержка 1 мс
	sendbyte(0b00101000, 0);  // 4бит-режим (DL=0) и 2 строки (N=1)
	_delay_ms(1);			  // задержка 1 мс
	sendbyte(0b00001100, 0);  // включаем изображение на дисплее (D=1), курсоры никакие не включаем (C=0, B=0)
	_delay_ms(1);			  // задержка 1 мс
	sendbyte(0b00000110, 0);  // курсор (хоть он у нас и невидимый) будет двигаться влево
	_delay_ms(1);			  // задержка 1 мс
}
// —————————————-

// —————————————-
void clearlcd() // функция очистки дисплея
{
	sendbyte(0b00000001, 0); // передача байта команды очистки
	_delay_ms(2);			 // задержка 2 мс
}
// —————————————-

// —————————————-
void str_lcd(char str1[]) // функция вывода на экран целой строки
{
	wchar_t n;						  // объявление переменной n типа wchar_t
	for (n = 0; str1[n] != '\0'; n++) // пока нет нулевого символа
		sendcharlcd(str1[n]);		  // выводим переданные символы на дисплей
}
// —————————————---------------------------------------------------------------------------------------------------------------------------конец определений функций для работы с ЖКИ

// —————————————-
uint8_t ADC_CH0_convert(void) // функция одиночного запуска 0-го канала АЦП (для 8-разрядного результата используем uint8_t)
{
	uint8_t res;						  // обявление переменной для хранения результата преобразования ADC
	ADCA_CTRLA |= (1 << ADC_CH0START_bp); // запуск преобразования в канале 0 ADC //Начинаем преобразование
	while (!(ADCA_CH0_INTFLAGS & ADC_CH_CHIF_bm))
		;
	ADCA_CH0_INTFLAGS = ADC_CH_CHIF_bm;
	res = ADCA_CH0RES; // задаём значение результата преобразования ADC
	return (res);	   // по окончании вернём результат в виде беззнаковой величины
}
// —————————————-

// —————————————-
uint8_t ADC_CH1_convert(void) // функция одиночного запуска 1-го канала АЦП (для 8-разрядного результата используем uint8_t)
{
	uint8_t res;						  // обявление переменной для хранения результата преобразования ADC
	ADCA_CTRLA |= (1 << ADC_CH1START_bp); // запуск преобразования в канале 1 ADC //Начинаем преобразование
	while (!(ADCA_CH1_INTFLAGS & ADC_CH_CHIF_bm))
		;
	ADCA_CH1_INTFLAGS = ADC_CH_CHIF_bm;
	res = ADCA_CH1RES; // задаём значение результата преобразования ADC
	return (res);	   // по окончании вернём результат в виде беззнаковой величины
}
// —————————————-

// —————————————-
uint8_t ADC_CH2_convert(void) // функция одиночного запуска 2-го канала АЦП (для 8-разрядного результата используем uint8_t)
{
	uint8_t res;						  // обявление переменной для хранения результата преобразования ADC
	ADCA_CTRLA |= (1 << ADC_CH2START_bp); // запуск преобразования в канале 2 ADC //Начинаем преобразование
	while (!(ADCA_CH2_INTFLAGS & ADC_CH_CHIF_bm))
		;
	ADCA_CH2_INTFLAGS = ADC_CH_CHIF_bm;
	res = ADCA_CH2RES; // задаём значение результата преобразования ADC
	return (res);	   // по окончании вернём результат в виде беззнаковой величины
}
// —————————————-

// —————————————-
uint8_t ADC_CH3_convert(void) // функция одиночного запуска 3-го канала АЦП (для 8-разрядного результата используем uint8_t)
{
	uint8_t res;						  // обявление переменной для хранения результата преобразования ADC
	ADCA_CTRLA |= (1 << ADC_CH3START_bp); // запуск преобразования в канале 3 ADC //Начинаем преобразование
	while (!(ADCA_CH3_INTFLAGS & ADC_CH_CHIF_bm))
		;
	ADCA_CH3_INTFLAGS = ADC_CH_CHIF_bm;
	res = ADCA_CH3RES; // задаём значение результата преобразования ADC
	return (res);	   // по окончании вернём результат в виде беззнаковой величины
}
// —————————————-

// —————————————
void kanal_select(uint8_t temp_kanal) // функция включения выбранного канала
{
	EN_OFF;					   // установка лог."0" на линии EN
	nomer_kanala = temp_kanal; // сохранение номера включенного канала
	_delay_us(10);			   // задержка 10 мкс

	switch (nomer_kanala)
	{
	case 0:
		A0_ON; // установка лог."1" на линии A0
		A1_ON; // установка лог."1" на линии A1
		break;

	case 1:
		A0_OFF; // установка лог."0" на линии A0
		A1_ON;	// установка лог."1" на линии A1
		break;

	case 2:
		A0_ON;	// установка лог."1" на линии A0
		A1_OFF; // установка лог."0" на линии A1
		break;

	case 3:
		A0_OFF; // установка лог."0" на линии A0
		A1_OFF; // установка лог."0" на линии A1
		break;
	}

	_delay_us(10); // задержка 10 мкс
	EN_ON;		   // установка лог."1" на линии EN
	_delay_us(10); // задержка 10 мкс
}
// ————————————

// —————————————
void Potentiometr_set(uint8_t PD) // функция установки потенциометра (PD задаёт число от 0 до 255, что примерно соответствует сопротивлению R(кОм) = 0,2*PD)
{
	Mas_data_PD[0] = 0;
	Mas_data_PD[1] = 0;
	Mas_data_PD[2] = 0;
	Mas_data_PD[3] = 1;
	Mas_data_PD[4] = 0;
	Mas_data_PD[5] = 0;
	Mas_data_PD[6] = 0;
	Mas_data_PD[7] = 1;				 // заполнение массива Mas_data_PD константами
	for (uint8_t i = 15; i > 7; i--) // цикл от 15 до 8
	{
		Mas_data_PD[i] = PD % 2; // расчёт i-го бита двоичного кода
		PD = PD / 2;			 // промежуточный расчёт
	}
	PORTA_OUT &= 0b11011111; // установка лог."0" на выходe PA5 порта A (начало передачи данных, линия CS)
	_delay_us(0.2);			 // задержка, равная половине периода

	for (uint8_t i = 0; i < 16; i++) // цикл от 1 до 15
	{
		if (Mas_data_PD[i] == 0) // если бит равен 0
		{
			PORTA_OUT &= 0b11110111; // установка лог "0" на выводе PA3 порта A (выставление бита данных, линия SI)
		}
		else
		{
			PORTA_OUT |= 0b00001000; // установка лог "1" на выводе PA3 порта A (выставление бита данных, линия SI)
		}
		_delay_us(0.1);			 // задержка, равная четверти периода
		PORTA_OUT |= 0b00010000; // установка лог "1" на выводе PA4 порта A (считывание бита данных, линия SCK)
		_delay_us(0.2);			 // задержка, равная половине периода
		PORTA_OUT &= 0b11101111; // установка лог "0" на выводе PA4 порта A (запись бита данных, линия SCK)
		_delay_us(0.1);			 // задержка, равная четверти периода
	}

	_delay_us(0.2);			 // задержка, равная половине периода
	PORTA_OUT |= 0b00100000; // установка лог."1" на выходe PA5 порта A (конец передачи данных, линия CS)
	PORTA_OUT &= 0b11110111; // установка лог "0" на выводе PA3 порта A
}
// —————————————

// —————————————
void generator(void) // функция запуска пачки импульсов частотой 200 кГц (длительность полупериода - 2,5 мкс)
{
	switch (nomer_kanala)
	{
	case 0:
		PORTC_OUT |= 0b00010000; // установка лог."1" на выходе PC4
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTC_OUT &= 0b11101111; // установка лог."0" на выходе PC4
		PORTC_OUT |= 0b00001000; // установка лог."1" на выходе PC3
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTC_OUT &= 0b11110111; // установка лог."0" на выходе PC3
		break;

	case 1:
		PORTC_OUT |= 0b00000100; // установка лог."1" на выходе PC2
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTC_OUT &= 0b11111011; // установка лог."0" на выходе PC2
		PORTC_OUT |= 0b00000010; // установка лог."1" на выходе PC1
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTC_OUT &= 0b11111101; // установка лог."0" на выходе PC1
		break;

	case 2:
		PORTB_OUT |= 0b00000010; // установка лог."1" на выходе PB1
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTB_OUT &= 0b11111101; // установка лог."0" на выходе PB1
		PORTB_OUT |= 0b00000001; // установка лог."1" на выходе PB0
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTB_OUT &= 0b11111110; // установка лог."0" на выходе PB0
		break;

	case 3:
		PORTA_OUT |= 0b10000000; // установка лог."1" на выходе PA7
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTA_OUT &= 0b01111111; // установка лог."0" на выходе PA7
		PORTA_OUT |= 0b01000000; // установка лог."1" на выходе PA6
		_delay_us(2.5);			 // задержка 2,5 мкс
		PORTA_OUT &= 0b10111111; // установка лог."0" на выходе PA6
		break;
	}
}
// ————————————

// —————————————
void func_eeprom_clear(void) // функция очистки EEPROM
{
	for (uint16_t i = 0; i < 99; i++)
	{
		eeprom_write_byte((uint8_t *)i, 0xFF); // запись в eeprom по текущуму адресу значения 0xFF
	}
}
// —————————————

// —————————————
void func_eeprom_read_ID(void) // функция чтения из eeprom данных ID (версия прошивки и серийный номер метеоблока)
{
	serial_number = eeprom_read_word((uint16_t *)102); // чтение из eeprom по адресу 102 значения серийного номера метеоблока

	if (((program_version_number) != (eeprom_read_byte((uint8_t *)100))) || ((program_variant_number) != (eeprom_read_byte((uint8_t *)101)))) // если номер версии или варианта прошивки метеоблока записанного в eeprom не равен их значению по умолчанию
	{
		eeprom_write_byte((uint8_t *)100, program_version_number); // запись в eeprom по адресу 100 номера версии прошивки метеоблока
		eeprom_write_byte((uint8_t *)101, program_variant_number); // запись в eeprom по адресу 100 номера варианта прошивки метеоблока
	}

	status_prog = eeprom_read_byte((uint8_t *)120); // чтение из eeprom по адресу 120 значения статуса прошивки метеоблока
	if ((status_prog) != 0xAA)						// если значение статуса прошивки метеоблока не равно значению 0xAA, записанному в eeprom
	{
		eeprom_write_byte((uint8_t *)120, 0xCC); // запись в eeprom по адресу 120 значения 0xCC
		CCP = 0xD8;								 // разрешение записи в защищённый регистр
		RST_CTRL = (1 << RST_SWRST_bp);			 // выполнение программного сброса микроконтроллера
	}
}
// —————————————

// —————————————
void func_eeprom_read(void) // функция чтения из eeprom данных калибровки
{
	uint16_t Data_eeprom; // объявление локальной переменной для записи значений в eeprom
	// int16_t Data_eeprom_bipolar; //объявление локальной переменной для записи биполярных значений в eeprom
	// uint8_t Data_eeprom_2; //объявление локальной переменной для записи значений в eeprom

	serial_number = eeprom_read_word((uint16_t *)102); // чтение из eeprom по адресу 102 значения серийного номера метеоблока

	if (((program_version_number) != (eeprom_read_byte((uint8_t *)100))) || ((program_variant_number) != (eeprom_read_byte((uint8_t *)101)))) // если номер версии или варианта прошивки метеоблока не равен значению, записанному в eeprom
	{
		eeprom_write_byte((uint8_t *)100, program_version_number); // запись в eeprom по адресу 100 номера версии прошивки метеоблока
		eeprom_write_byte((uint8_t *)101, program_variant_number); // запись в eeprom по адресу 100 номера варианта прошивки метеоблока
	}

	status_kal_K0 = eeprom_read_byte((uint8_t *)0);	   // чтение из eeprom по адресу 0 статуса калибровки без ветра
	status_kal_X = eeprom_read_byte((uint8_t *)1);	   // чтение из eeprom по адресу 1 статуса калибровки с ветром по оси X положительного направления
	status_kal_Y = eeprom_read_byte((uint8_t *)2);	   // чтение из eeprom по адресу 2 статуса калибровки с ветром по оси Y отрицательного направления
	status_kal_T = eeprom_read_byte((uint8_t *)3);	   // чтение из eeprom по адресу 3 статуса калибровки температуры и температуры подогрева метеоблока
	status_kal_Th_on = eeprom_read_byte((uint8_t *)4); // чтение из eeprom по адресу 4 статуса температуры подогрева метеоблока
	status_kal_H = eeprom_read_byte((uint8_t *)5);	   // чтение из eeprom по адресу 5 статуса калибровки влажности метеоблока
	status_kal_P = eeprom_read_byte((uint8_t *)6);	   // чтение из eeprom по адресу 6 статуса калибровки давления метеоблока

	if (status_kal_K0 == 1) // если статус калибровки без ветра равен 1
	{
		Mas_basedPD[0] = eeprom_read_byte((uint8_t *)10); // чтение из eeprom по адресу 10 значения калибровки усиления 1-го канала 0-го уровня
		Mas_basedPD[1] = eeprom_read_byte((uint8_t *)11); // чтение из eeprom по адресу 11 значения калибровки усиления 2-го канала 0-го уровня
		Mas_basedPD[2] = eeprom_read_byte((uint8_t *)12); // чтение из eeprom по адресу 12 значения калибровки усиления 3-го канала 0-го уровня
		Mas_basedPD[3] = eeprom_read_byte((uint8_t *)13); // чтение из eeprom по адресу 13 значения калибровки усиления 4-го канала 0-го уровня

		for (uint8_t i = 0; i < 4; i++)
		{
			Mas_previousPD[i] = Mas_basedPD[i];
		}
		// Polar_gen=eeprom_read_byte((uint8_t*)14); //чтение из eeprom по адресу 14 значения полярности для пар каналов

		dT_k0_k1_null = (int16_t)(eeprom_read_word((uint16_t *)20)); // чтение из eeprom по адресу 20 значения разницы времени прохождения сигнала в канале 1 и канале 2 (в тактах микроконтроллера)
		dT_k2_k3_null = (int16_t)(eeprom_read_word((uint16_t *)22)); // чтение из eeprom по адресу 22 значения разницы времени прохождения сигнала в канале 1 и канале 2 (в тактах микроконтроллера)
		dTx = eeprom_read_word((uint16_t *)24);						 // чтение из eeprom по адресу 24 значения задержки dTx (в тактах микроконтроллера)
		dTy = eeprom_read_word((uint16_t *)26);						 // чтение из eeprom по адресу 26 значения задержки dTy (в тактах микроконтроллера)
		Tx = eeprom_read_word((uint16_t *)28);						 // чтение из eeprom по адресу 28 значения задержки Tx (в десятых долях мкс)
		Ty = eeprom_read_word((uint16_t *)30);						 // чтение из eeprom по адресу 30 значения задержки Ty (в десятых долях мкс)
		Ct = eeprom_read_word((uint16_t *)32);						 // чтение из eeprom по адресу 32 значения скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с)
	}
	else // иначе
	{
		Mas_basedPD[0] = KU; // присвоить начальное значение переменной для задания коэффициента усиления 1-го канала 0-го уровня
		Mas_basedPD[1] = KU; // присвоить начальное значение переменной для задания коэффициента усиления 2-го канала 0-го уровня
		Mas_basedPD[2] = KU; // присвоить начальное значение переменной для задания коэффициента усиления 3-го канала 0-го уровня
		Mas_basedPD[3] = KU; // присвоить начальное значение переменной для задания коэффициента усиления 4-го канала 0-го уровня

		// Polar_gen=0; //присвоить начальное значение "0" переменной значения полярности для пар каналов

		dT_k0_k1_null = dT_k_null; // присвоить переменной для хранения разницы времени прохождения сигнала в канале 1 и канале 2 начальное значение в нс
		dT_k2_k3_null = dT_k_null; // присвоить переменной для хранения разницы времени прохождения сигнала в канале 3 и канале 4 начальное значение в нс
		dTx = dT;				   // присвоить переменной задержки dTx начальное значение (в тактах микроконтроллера)
		dTy = dT;				   // присвоить переменной задержки dTy начальное значение (в тактах микроконтроллера)
		Tx = Tob;				   // присвоить переменной задержки Tx начальное значение (в десятых долях мкс)
		Ty = Tob;				   // присвоить переменной задержки Ty начальное значение (в десятых долях мкс)
		Ct = Cul;				   // присвоить переменной скорости ультразвука в воздухе значения скорости ультразвука в воздухе по умолчанию (в дм/с)
	}

	if (status_kal_X == 1) // если статус калибровки с ветром по оси X равен 1
	{
		Data_eeprom = eeprom_read_word((uint16_t *)40); // чтение из eeprom по адресу 40 длины пути ультразвука Sx_kal (в десятых долях мм)
		Sx_kal = (double)(Data_eeprom);					// приведение типа данных переменной Sx_kal
		Data_eeprom = eeprom_read_word((uint16_t *)42); // чтение из eeprom по адресу 42 общей задержки Tx_kal (в десятых долях мкс)
		Tx_kal = (double)(Data_eeprom);					// приведение типа данных переменной Tx_kal
	}
	else // иначе
	{
		Sx_kal = S;	  // присвоить начальное значение переменной Sx_kal (в десятых долях мм)
		Tx_kal = Tob; // присвоить начальное значение переменной Tx_kal (в десятых долях мкс)
	}

	if (status_kal_Y == 1) // если статус калибровки с ветром по оси Y равен 1
	{
		Data_eeprom = eeprom_read_word((uint16_t *)50); // чтение из eeprom по адресу 50 длины пути ультразвука Sy_kal (в десятых долях мм)
		Sy_kal = (double)(Data_eeprom);					// приведение типа данных переменной Sy_kal
		Data_eeprom = eeprom_read_word((uint16_t *)52); // чтение из eeprom по адресу 52 общей задержки Ty_kal (в десятых долях мкс)
		Ty_kal = (double)(Data_eeprom);					// приведение типа данных переменной Ty_kal
	}
	else // иначе
	{
		Sy_kal = S;	  // присвоить начальное значение переменной Sy_kal (в десятых долях мм)
		Ty_kal = Tob; // присвоить начальное значение переменной Ty_kal (в десятых долях мкс)
	}

	if (status_kal_T == 1) // если статус калибровки температуры и температуры подогрева метеоблока равен 1
	{
		Data_eeprom = eeprom_read_word((uint16_t *)60); // чтение из eeprom по адресу 60 точки нижнего значения температуры эталона (в десятых долях градуса Цельсия)
		Tst_low = (double)((int16_t)(Data_eeprom));		// приведение типа данных переменной Tst_low
		Data_eeprom = eeprom_read_word((uint16_t *)62); // чтение из eeprom по адресу 62 точки верхнего значения температуры эталона (в десятых долях градуса Цельсия)
		Tst_high = (double)((int16_t)(Data_eeprom));	// приведение типа данных переменной Tst_high
		Data_eeprom = eeprom_read_word((uint16_t *)64); // чтение из eeprom по адресу 64 точки нижнего значения температуры метеоблока (в десятых долях градуса Цельсия)
		Tm_low = (double)((int16_t)(Data_eeprom));		// приведение типа данных переменной Tm_low
		Data_eeprom = eeprom_read_word((uint16_t *)66); // чтение из eeprom по адресу 66 точки верхнего значения температуры метеоблока (в десятых долях градуса Цельсия)
		Tm_high = (double)((int16_t)(Data_eeprom));		// приведение типа данных переменной Tm_high
		Data_eeprom = eeprom_read_word((uint16_t *)68); // чтение из eeprom по адресу 68 точки нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия)
		Th_low = (double)((int16_t)(Data_eeprom));		// приведение типа данных переменной Th_low
		Data_eeprom = eeprom_read_word((uint16_t *)70); // чтение из eeprom по адресу 70 точки верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия)
		Th_high = (double)((int16_t)(Data_eeprom));		// приведение типа данных переменной Th_high
	}
	else // иначе
	{
		Tst_low = -400; // присвоить начальное значение переменной Tst_low (в десятых долях градуса Цельсия)
		Tst_high = 600; // присвоить начальное значение переменной Tst_high (в десятых долях градуса Цельсия)
		Tm_low = -400;	// присвоить начальное значение переменной Tm_low (в десятых долях градуса Цельсия)
		Tm_high = 600;	// присвоить начальное значение переменной Tm_high (в десятых долях градуса Цельсия)
		Th_low = -400;	// присвоить начальное значение переменной Th_low (в десятых долях градуса Цельсия)
		Th_high = 600;	// присвоить начальное значение переменной Th_high (в десятых долях градуса Цельсия)
	}

	if (status_kal_Th_on == 1) // если статус температуры подогрева метеоблока равен 1
	{
		Th_on = eeprom_read_word((uint16_t *)72); // чтение из eeprom по адресу 72 точки значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия)
	}
	else // иначе
	{
		Th_on = 20; // присвоить начальное значение переменной Th_on (в десятых долях градуса Цельсия)
	}

	if (status_kal_H == 1) // если статус калибровки влажности метеоблока равен 1
	{
		Data_eeprom = eeprom_read_word((uint16_t *)80); // чтение из eeprom по адресу 80 точки нижнего значения влажности эталона (в десятых долях процента)
		Hst_low = (double)(Data_eeprom);				// приведение типа данных переменной Hst_low
		Data_eeprom = eeprom_read_word((uint16_t *)82); // чтение из eeprom по адресу 82 точки верхнего значения влажности эталона (в десятых долях процента)
		Hst_high = (double)(Data_eeprom);				// приведение типа данных переменной Hst_high
		Data_eeprom = eeprom_read_word((uint16_t *)84); // чтение из eeprom по адресу 84 точки нижнего значения влажности метеоблока (в десятых долях процента)
		Hm_low = (double)(Data_eeprom);					// приведение типа данных переменной Hm_low
		Data_eeprom = eeprom_read_word((uint16_t *)86); // чтение из eeprom по адресу 86 точки верхнего значения влажности метеоблока (в десятых долях процента)
		Hm_high = (double)(Data_eeprom);				// приведение типа данных переменной Hm_high
	}
	else // иначе
	{
		Hst_low = 100;	// присвоить начальное значение переменной Hst_low (в десятых долях процента)
		Hst_high = 950; // присвоить начальное значение переменной Hst_high (в десятых долях процента)
		Hm_low = 100;	// присвоить начальное значение переменной Hm_low (в десятых долях процента)
		Hm_high = 950;	// присвоить начальное значение переменной Hm_high (в десятых долях процента)
	}

	if (status_kal_P == 1) // если статус калибровки давления метеоблока равен 1
	{
		Data_eeprom = eeprom_read_word((uint16_t *)90); // чтение из eeprom по адресу 90 точки нижнего значения давления эталона (в десятых долях мм ртутного столба)
		Pst_low = (double)(Data_eeprom);				// приведение типа данных переменной Pst_low
		Data_eeprom = eeprom_read_word((uint16_t *)92); // чтение из eeprom по адресу 92 точки верхнего значения давления эталона (в десятых долях мм ртутного столба)
		Pst_high = (double)(Data_eeprom);				// приведение типа данных переменной Pst_high
		Data_eeprom = eeprom_read_word((uint16_t *)94); // чтение из eeprom по адресу 94 точки нижнего значения давления метеоблока (в десятых долях мм ртутного столба)
		Pm_low = (double)(Data_eeprom);					// приведение типа данных переменной Pm_low
		Data_eeprom = eeprom_read_word((uint16_t *)96); // чтение из eeprom по адресу 96 точки верхнего значения давления метеоблока (в десятых долях мм ртутного столба)
		Pm_high = (double)(Data_eeprom);				// приведение типа данных переменной Pm_high
	}
	else // иначе
	{
		Pst_low = 4500;	 // присвоить начальное значение переменной Pst_low (в десятых долях мм ртутного столба)
		Pst_high = 7500; // присвоить начальное значение переменной Pst_high (в десятых долях мм ртутного столба)
		Pm_low = 4500;	 // присвоить начальное значение переменной Pm_low (в десятых долях мм ртутного столба)
		Pm_high = 7500;	 // присвоить начальное значение переменной Pm_high (в десятых долях мм ртутного столба)
	}
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------- Функции вывода данных (начало)
// —————————————
void func_vyvod_skorost_V(void) // функция вывода скорости ветра в cм/с
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	Mas_amplitude_operativ[0][2] = 255;
	Mas_amplitude_operativ[0][0] = 240;

	if (abs(Mas_amplitude_operativ[0][2]) - abs(Mas_amplitude_operativ[0][0]) > 4)
	// если амплитуда предыдущего импульса той же полярности меньше амплитуды текущего импульса минимум на 5 единиц 8-разрядного кода АЦП
	{
		str_lcd("Delta: yes"); // выводим надпись
	}

	else
	{
		str_lcd("Delta: noy"); // выводим надпись
	}

	_delay_ms(10000);
}
// —————————————

// —————————————
void func_vyvod_skorost_Vx_Vy(void) // функция вывода скорости ветра по осям в дм/с
{
	int16_t temp_C; // вспомогательная переменная

	clearlcd();		 // очистка дисплея
	setpos(0, 0);	 // устанавливаем курсор в начальное положение первой строки
	str_lcd("Vx: "); // выводим надпись "Vx: "
	if (Vx < 0)		 // если значение скорости ветра Vx меньше нуля
	{
		str_lcd("-");					// выводим надпись "-"
		temp_C = -(int16_t)(round(Vx)); // изменение знака и приведение значения Vx к дм/с
	}
	else
	{
		str_lcd("+");				   // выводим надпись "+"
		temp_C = (int16_t)(round(Vx)); // приведение значения Vx к дм/с
	}
	sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30); // Преобразуем число в код числа
	sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);  // Преобразуем число в код числа
	str_lcd(",");									   // выводим надпись ","
	sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);   // Преобразуем число в код числа
	str_lcd(" ј/c");								   // выводим надпись " м/с"

	setpos(0, 1);	 // устанавливаем курсор в начальное положение второй строки
	str_lcd("Vy: "); // выводим надпись "Vy: "
	if (Vy < 0)		 // если значение скорости ветра Vy меньше нуля
	{
		str_lcd("-");					// выводим надпись "-"
		temp_C = -(int16_t)(round(Vy)); // изменение знака и приведение значения Vx к дм/с
	}
	else
	{
		str_lcd("+");				   // выводим надпись "+"
		temp_C = (int16_t)(round(Vy)); // приведение значения Vy к дм/с
	}
	sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30); // Преобразуем число в код числа
	sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);  // Преобразуем число в код числа
	str_lcd(",");									   // выводим надпись ","
	sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);   // Преобразуем число в код числа
	str_lcd(" ј/c");								   // выводим надпись " м/с"
}
// —————————————

// —————————————
void func_vyvod_skorost_Cx_Cy(void) // функция вывода времени начальной задержки прихода пачки импульсов (в мм) и скорости ультразвука по осям (в м/с)
{
	clearlcd();										// очистка дисплея
	setpos(0, 0);									// устанавливаем курсор в начальное положение первой строки
	str_lcd("Cx: ");								// выводим надпись "Cx: "
	sendcharlcd((uint16_t)(Cx / 1000) % 10 + 0x30); // Преобразуем число в код числа
	sendcharlcd((uint16_t)(Cx / 100) % 10 + 0x30);	// Преобразуем число в код числа
	sendcharlcd((uint16_t)(Cx / 10) % 10 + 0x30);	// Преобразуем число в код числа
	str_lcd(",");									// выводим надпись ","
	sendcharlcd((uint16_t)(Cx / 1) % 10 + 0x30);	// Преобразуем число в код числа
	str_lcd(" ј/c");								// выводим надпись " м/с"

	setpos(0, 1);									// устанавливаем курсор в начальное положение второй строки
	str_lcd("Cy: ");								// выводим надпись "Cy: "
	sendcharlcd((uint16_t)(Cy / 1000) % 10 + 0x30); // Преобразуем число в код числа
	sendcharlcd((uint16_t)(Cy / 100) % 10 + 0x30);	// Преобразуем число в код числа
	sendcharlcd((uint16_t)(Cy / 10) % 10 + 0x30);	// Преобразуем число в код числа
	str_lcd(",");									// выводим надпись ","
	sendcharlcd((uint16_t)(Cy / 1) % 10 + 0x30);	// Преобразуем число в код числа
	str_lcd(" ј/c");								// выводим надпись " м/с"
}
// —————————————

// —————————————
void func_vyvod_TPH(void) // функция вывода данных температуры, давления и влажности с модуля BME280
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	if (Status_error_BME280 == 0) // если нет ошибки связи с модулем BME280
	{
		str_lcd("Teјѕ.=");				   // выводим надпись "Темп.="
		if (BME280_compensate_T_znak == 0) // если температура положительная
		{
			str_lcd("+"); // выводим знак "+"
		}
		else // иначе
		{
			str_lcd("-"); // выводим знак "-"
		}
		sendcharlcd((uint16_t)(BME280_compensate_T1) % 10 + 0x30); // вывод температуры (разряд десятков градусов Цельсия)
		sendcharlcd((uint16_t)(BME280_compensate_T2) % 10 + 0x30); // вывод температуры (разряд единиц градусов Цельсия)
		str_lcd(",");											   // выводим знак ","
		sendcharlcd((uint16_t)(BME280_compensate_T3) % 10 + 0x30); // вывод температуры (разряд десятых долей градуса Цельсия)
		str_lcd(" ");											   // выводим пробел " "
		// sendcharlcd(0x60); //выводим знак "градус"
		sendcharlcd(0xDF);	// выводим знак "градус"
		str_lcd("C      "); // выводим надпись "C      "

		str_lcd("аaі».=");										   // выводим надпись "Давл.="
		sendcharlcd((uint16_t)(BME280_compensate_P1) % 10 + 0x30); // вывод давления (разряд сотен мм рт. ст.)
		sendcharlcd((uint16_t)(BME280_compensate_P2) % 10 + 0x30); // вывод давления (разряд десятков мм рт. ст.)
		sendcharlcd((uint16_t)(BME280_compensate_P3) % 10 + 0x30); // вывод давления (разряд единиц мм рт. ст.)
		str_lcd(",");											   // выводим знак ","
		sendcharlcd((uint16_t)(BME280_compensate_P4) % 10 + 0x30); // вывод давления (разряд десятых долей мм рт. ст.)
		str_lcd(" јј pї.cї");									   // выводим надпись " мм рт.ст"

		setpos(0, 1);											   // устанавливаем курсор в начальное положение 2-й строки
		str_lcd("B»a¶.=");										   // выводим надпись "Влаж.="
		sendcharlcd((uint16_t)(BME280_compensate_H1) % 10 + 0x30); // вывод влажности (разряд десятков процентов относительной влажности)
		sendcharlcd((uint16_t)(BME280_compensate_H2) % 10 + 0x30); // вывод влажности (разряд единиц процентов относительной влажности)
		str_lcd(",");											   // выводим знак ","
		sendcharlcd((uint16_t)(BME280_compensate_H3) % 10 + 0x30); // вывод влажности (разряд десятых долей процентов относительной влажности)
		str_lcd(" ");											   // выводим пробел " "
		sendcharlcd(0x25);										   // вывод знака "проценты"
		str_lcd("        ");									   // выводим пробелы "        "
	}

	else // если есть ошибки связи с модулем BME280
	{
		str_lcd("OБёІєa cіЗ·ё BME280 "); // выводим надпись "Ошибка связи ВМЕ280 "
	}
}
// —————————————

// —————————————
void func_vyvod_T(void) // функция вывода данных температуры с датчика DS18B20
{
	int16_t T; // переменная для хранения вспомогательной температуры (десятые доли градусов Цельсия)

	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	if (Status_error_DS18B20 == 0) // если нет ошибки связи с датчиком DS18B20
	{
		// Status_error_DS18B20=0; //обнуление переменной статуса ошибки связи с датчиком DS18B20
		str_lcd("Teјѕ.Ѕaґp.="); // выводим надпись "Темп.нагр.="

		if (DS18B20_T_full < 0) // если текущая температура отрицательтельная
		{
			str_lcd("-");		 // выводим знак "-"
			T = -DS18B20_T_full; // преобразование переменной для хранения вспомогательной температуры (десятые доли градусов Цельсия) в положительное число
		}
		else // иначе
		{
			str_lcd("+");		// выводим знак "+"
			T = DS18B20_T_full; // сохранение переменной для хранения вспомогательной температуры (десятые доли градусов Цельсия)
		}
		sendcharlcd((uint16_t)(T / 100) % 10 + 0x30); // вывод
		sendcharlcd((uint16_t)(T / 10) % 10 + 0x30);  // вывод
		str_lcd(",");								  // выводим знак ","
		sendcharlcd((uint16_t)(T / 1) % 10 + 0x30);	  // вывод
		str_lcd(" ");								  // выводим пробел " "
		sendcharlcd(0xDF);							  // выводим знак "градус"
		str_lcd("C ");								  // выводим надпись "C "

		str_lcd("Cocї. Ѕaґp.= "); // выводим надпись "Сост. нагр.= "
		sendcharlcd(0x3C);		  // выводим знак "<"
		if (Status_Nagrevatel_ON) // если нагреватель включён
		{
			str_lcd("Bє».");   // выводим надпись " ON"
			sendcharlcd(0x3E); // выводим знак ">"
			str_lcd(" ");	   // выводим пробел " "
		}
		else // иначе
		{
			str_lcd("BГє».");  // выводим надпись "OFF"
			sendcharlcd(0x3E); // выводим знак ">"
		}

		setpos(0, 1);			 // устанавливаем курсор в начальное положение второй строки
		str_lcd("Teјѕ. ѕopoґ="); // выводим надпись "Темп. порог="
		if (Th_on < 0)			 // если температура включения подогрева метеоблока (в десятых долях градуса Цельсия) отрицательтельная
		{
			str_lcd("-"); // выводим знак "-"
			T = -Th_on;	  // преобразование температуры включения подогрева метеоблока (в десятых долях градуса Цельсия) в положительное число
		}
		else // иначе
		{
			str_lcd("+"); // выводим знак "+"
			T = Th_on;	  // сохранение температуры включения подогрева метеоблока (в десятых долях градуса Цельсия)
		}
		sendcharlcd((uint16_t)(T / 100) % 10 + 0x30); // вывод
		sendcharlcd((uint16_t)(T / 10) % 10 + 0x30);  // вывод
		str_lcd(",");								  // выводим знак ","
		sendcharlcd((uint16_t)(T / 1) % 10 + 0x30);	  // вывод
		str_lcd(" ");								  // выводим пробел " "
		sendcharlcd(0xDF);							  // выводим знак "градус"
		str_lcd("C    ");							  // выводим надпись "C    "
	}

	else // если есть ошибки связи с датчиком DS18B20
	{
		str_lcd("OБёІєa cіЗ·ё DS18B20"); // выводим надпись "Ошибка связи DS18B20"
	}
}
// —————————————

// —————————————
void func_vyvod_status_error(void) // функция вывода ошибки приёма данных
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	str_lcd("S_error_BME280="); // выводим надпись "Ошибка измерения"
	// str_lcd("OБёІєa ё·јepeЅёЗ"); //выводим надпись "Ошибка измерения"
	// setpos(0,1); //устанавливаем курсор в начальное положение второй строки

	sendcharlcd((uint16_t)(Status_error_BME280) % 10 + 0x30); // вывод количества десятков числа nomer
	// str_lcd(" cєopocїё іeїpa "); //выводим надпись " скорости ветра "
	_delay_ms(3000); // задержка 3 с
}
// —————————————

// —————————————
void func_vyvod_kalibr_status(void) // функция вывода статуса калибровки
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	str_lcd("KU:");			// выводим надпись "KU:"
	if (status_kal_KU == 1) // если статус калибровки усиления равен 1
	{
		str_lcd("+"); // выводим надпись "+"
	}
	else // иначе
	{
		str_lcd("-"); // выводим надпись "-"
	}

	str_lcd("  X_kal:"); // выводим надпись "  X_kal:"

	if (status_kal_X == 1) // если статус калибровки с ветром по оси X положительного направления равен 1
	{
		str_lcd("+"); // выводим надпись "+"
	}
	else // иначе
	{
		str_lcd("-"); // выводим надпись "-"
	}

	setpos(0, 1); // устанавливаем курсор в начальное положение второй строки

	str_lcd("K0:");			// выводим надпись "K0:"
	if (status_kal_K0 == 1) // если статус калибровки без ветра равен 1
	{
		str_lcd("+"); // выводим надпись "+"
	}
	else // иначе
	{
		str_lcd("-"); // выводим надпись "-"
	}

	str_lcd("  Y_kal:"); // выводим надпись "  Y_kal:"

	if (status_kal_Y == 1) // если статус калибровки с ветром по оси Y отрицательного направления равен 1
	{
		str_lcd("+"); // выводим надпись "+"
	}
	else // иначе
	{
		str_lcd("-"); // выводим надпись "-"
	}
}
// —————————————

// —————————————
void func_vyvod_kalibr_usil(void) // функция вывода калибровки усиления (для 4-х каналов)
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	if (Status_error_anemometr == 0) // если нет ошибки связи с анемометром
	{
		clearlcd();												   // очистка дисплея
		setpos(0, 0);											   // устанавливаем курсор в начальное положение первой строки
		str_lcd(" K1=");										   // выводим надпись " K1="
		sendcharlcd((uint16_t)(Mas_basedPD[0] / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[0] / 10) % 10 + 0x30);  // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[0] / 1) % 10 + 0x30);   // Преобразуем число в код числа
		str_lcd("      K3=");									   // выводим надпись "      K3="
		sendcharlcd((uint16_t)(Mas_basedPD[2] / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[2] / 10) % 10 + 0x30);  // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[2] / 1) % 10 + 0x30);   // Преобразуем число в код числа
		str_lcd(" ");											   // выводим надпись " "

		setpos(0, 1);											   // устанавливаем курсор в начальное положение второй строки
		str_lcd(" K2=");										   // выводим надпись " K2="
		sendcharlcd((uint16_t)(Mas_basedPD[1] / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[1] / 10) % 10 + 0x30);  // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[1] / 1) % 10 + 0x30);   // Преобразуем число в код числа
		str_lcd("      K4=");									   // выводим надпись "      K4="
		sendcharlcd((uint16_t)(Mas_basedPD[3] / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[3] / 10) % 10 + 0x30);  // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Mas_basedPD[3] / 1) % 10 + 0x30);   // Преобразуем число в код числа
		str_lcd(" ");											   // выводим надпись "     "
	}

	else // если есть ошибки связи с анемометром
	{
		str_lcd(" OБёІєa єa»ёІpoієё  ");								  // выводим надпись " Ошибка калибровки  "
		setpos(0, 1);													  // устанавливаем курсор в начальное положение 2-й строки
		str_lcd(" aЅeјoјeїpa (єoг ");									  // выводим надпись " анемометра (код "
		sendcharlcd((uint16_t)(Status_error_anemometr / 10) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Status_error_anemometr / 1) % 10 + 0x30);  // Преобразуем число в код числа
		str_lcd(")");													  // выводим надпись ")"
	}
}
// —————————————

// —————————————
void func_vyvod_kalibr_null(void) // функция вывода калибровки (для оси Х и оси У разница времени без ветра в мкс)
{
	int16_t temp_C; // вспомогательная переменная

	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки

	if (Status_error_anemometr == 0) // если нет ошибки связи с анемометром
	{
		str_lcd("Tx=");									// выводим надпись "Tx="
		sendcharlcd((uint16_t)(Tx / 1000) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Tx / 100) % 10 + 0x30);	// Преобразуем число в код числа
		sendcharlcd((uint16_t)(Tx / 10) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(",");									// выводим надпись ","
		sendcharlcd((uint16_t)(Tx / 1) % 10 + 0x30);	// Преобразуем число в код числа

		str_lcd("   Ty=");								// выводим надпись "   Ty="
		sendcharlcd((uint16_t)(Ty / 1000) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Ty / 100) % 10 + 0x30);	// Преобразуем число в код числа
		sendcharlcd((uint16_t)(Ty / 10) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(",");									// выводим надпись ","
		sendcharlcd((uint16_t)(Ty / 1) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(" ");									// выводим надпись " "

		str_lcd("dX=");		   // выводим надпись "dX="
		if (dT_k0_k1_null < 0) // если значение переменной для хранения разницы времени прохождения сигнала в канале 1 и канале 2 меньше нуля
		{
			str_lcd("-");												// выводим надпись "-"
			temp_C = -(int16_t)(round((double)(dT_k0_k1_null) / 0.64)); // изменение знака и приведение значения dT_k0_k1_null к сотым долям мкс
		}
		else
		{
			str_lcd("+");											   // выводим надпись "+"
			temp_C = (int16_t)(round((double)(dT_k0_k1_null) / 0.64)); // приведение значения dT_k0_k1_null к сотым долям мкс
		}
		sendcharlcd((uint16_t)(temp_C / 1000) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(",");										// выводим надпись ","
		sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);	// Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);	// Преобразуем число в код числа

		str_lcd("  dY=");	   // выводим надпись "  dY="
		if (dT_k2_k3_null < 0) // если значение переменной для хранения разницы времени прохождения сигнала в канале 3 и канале 4 меньше нуля
		{
			str_lcd("-");												// выводим надпись "-"
			temp_C = -(int16_t)(round((double)(dT_k2_k3_null) / 0.64)); // изменение знака и приведение значения dT_k2_k3_null к сотым долям мкс
		}
		else
		{
			str_lcd("+");											   // выводим надпись "+"
			temp_C = (int16_t)(round((double)(dT_k2_k3_null) / 0.64)); // приведение значения dT_k2_k3_null к сотым долям мкс
		}
		sendcharlcd((uint16_t)(temp_C / 1000) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(",");										// выводим надпись ","
		sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);	// Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(" ");										// выводим надпись " "

		setpos(0, 1);									   // устанавливаем курсор в начальное положение второй строки
		str_lcd("dTx=");								   // выводим надпись "dTx="
		temp_C = (int16_t)(round((double)(dTx) / 6.4));	   // приведение значения dTx к десятым долям мкс
		sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);  // Преобразуем число в код числа
		str_lcd(",");									   // выводим надпись ","
		sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);   // Преобразуем число в код числа

		str_lcd("   dTy=");								   // выводим надпись "   dTy= "
		temp_C = (int16_t)(round((double)(dTy) / 6.4));	   // приведение значения dTy к десятым долям мкс
		sendcharlcd((uint16_t)(temp_C / 100) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(temp_C / 10) % 10 + 0x30);  // Преобразуем число в код числа
		str_lcd(",");									   // выводим надпись ","
		sendcharlcd((uint16_t)(temp_C / 1) % 10 + 0x30);   // Преобразуем число в код числа
		str_lcd(" ");									   // выводим надпись " "

		str_lcd("   Ct=");								// выводим надпись "   Ct="
		sendcharlcd((uint16_t)(Ct / 1000) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Ct / 100) % 10 + 0x30);	// Преобразуем число в код числа
		sendcharlcd((uint16_t)(Ct / 10) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(",");									// выводим надпись ","
		sendcharlcd((uint16_t)(Ct / 1) % 10 + 0x30);	// Преобразуем число в код числа
		str_lcd(" ј/c   ");								// выводим надпись " м/с   "
	}

	else // если есть ошибки связи с анемометром
	{
		str_lcd("  OБёІєa ё·јepeЅёЗ  ");								  // выводим надпись "  Ошибка измерения  "
		setpos(0, 1);													  // устанавливаем курсор в начальное положение 2-й строки
		str_lcd(" aЅeјoјeїpa (єoг ");									  // выводим надпись " анемометра (код "
		sendcharlcd((uint16_t)(Status_error_anemometr / 10) % 10 + 0x30); // Преобразуем число в код числа
		sendcharlcd((uint16_t)(Status_error_anemometr / 1) % 10 + 0x30);  // Преобразуем число в код числа
		str_lcd(")");													  // выводим надпись ")"
	}
}
// —————————————

// —————————————
void func_otobr_menu(void) // функция отображения меню
{
	clearlcd();	  // очистка дисплея
	setpos(0, 0); // устанавливаем курсор в начальное положение первой строки
	switch (tek_menu)
	{
	case 1000:
		str_lcd("1 CІpoc Ѕacїpoeє     "); // выводим надпись "1 Сброс настроек     "
		break;
	case 2000:
		str_lcd("2 аaЅЅГe BME280     "); // выводим надпись "2 Данные BME280     "
		break;
	case 3000:
		str_lcd("3 аaЅЅГe DS18B20    "); // выводим надпись "3 Данные DS18B20    "
		break;
	case 4000:
		str_lcd("4 AЅeјoјeїp   "); // выводим надпись "4 Анемометр         "
		break;
	case 4100:
		str_lcd("4.1 Ёoєa·aЅёЗ       "); // выводим надпись "4.1 Показания"
		setpos(0, 1);					 // устанавливаем курсор в начальное положение второй строки
		str_lcd("    aЅeјoјeїpa      "); // выводим надпись "    анемометра      "
		break;
	case 4200:
		str_lcd("4.2 Ka»ёІpoієa      "); // выводим надпись "4.2 Калибровка"
		break;
	case 4300:
		str_lcd(" 4.3 Teєyжёe гaЅЅГe "); // выводим надпись "4.3 Текущие данные "
		setpos(0, 1);					 // устанавливаем курсор в начальное положение второй строки
		str_lcd("    єa»ёІpoієё      "); // выводим надпись "    калибровки      "
		break;
	case 4400:
		str_lcd("4.4 ЎeЅepaїop       "); // выводим надпись "4.4 Генератор       "
		break;
	}
}
// ————————————
//---------------------------------------------------------------------------------------------------------------------------- Функции вывода данных (конец)

//---------------------------------------------------------------------------------------------------------------------------- Функции сбора данных (начало)
// —————————————
void func_izm_ADC_virtual_null(void) // функция измерения виртуального нуля АЦП
{
	uint32_t Sum = 0; // объявление локальной переменной для хранения суммы значений измерений АЦП

	for (int8_t i = 0; i < 100; i++) // цикл от 0 до 99
	{
		ADC_virtual_null = ADC_CH0_convert(); // вызов функции одиночного запуска 0-го канала АЦП и записи 8-разрядного значения в переменную ADC_virtual_null
		Sum = Sum + ADC_virtual_null;		  // суммирование измерений АЦП
		ADC_virtual_null = ADC_CH1_convert(); // вызов функции одиночного запуска 1-го канала АЦП и записи 8-разрядного значения в переменную ADC_virtual_null
		Sum = Sum + ADC_virtual_null;		  // суммирование измерений АЦП
		ADC_virtual_null = ADC_CH2_convert(); // вызов функции одиночного запуска 2-го канала АЦП и записи 8-разрядного значения в переменную ADC_virtual_null
		Sum = Sum + ADC_virtual_null;		  // суммирование измерений АЦП
		ADC_virtual_null = ADC_CH3_convert(); // вызов функции одиночного запуска 3-го канала АЦП и записи 8-разрядного значения в переменную ADC_virtual_null
		Sum = Sum + ADC_virtual_null;		  // суммирование измерений АЦП
	}
	ADC_virtual_null = (uint8_t)(round((double)(Sum) / 400)); // вычисление среднего результата измерения АЦП

	/*
	clearlcd(); //очистка дисплея
	setpos(0,0); //устанавливаем курсор в начальное положение первой строки
	str_lcd("ADC_virtual_null"); //выводим надпись "ADC_virtual_null"
	setpos(6,1); //устанавливаем курсор в 6-е положение второй строки
	sendcharlcd((uint16_t) (ADC_virtual_null/100)%10+0x30);//Преобразуем число в код числа
	sendcharlcd((uint16_t) (ADC_virtual_null/10)%10+0x30);//Преобразуем число в код числа
	sendcharlcd((uint16_t) (ADC_virtual_null/1)%10+0x30);//Преобразуем число в код числа
	_delay_ms(2000); //задержка 2 с
	*/
}
// ———————————

// —————————————
void func_operativ_mas(uint8_t nom_kan, uint8_t porog) // функция создания оперативного (урезанного) массива для выбранного канала (nom_kan=0...3) с пороговым значения АЦП porog (в 8-ми разрядном коде)
{
	// заполнение оперативного массива из N_operativ элементов

	uint8_t i;
	for (i = 4; i < (101 - (N_operativ - Ns_operativ)); i++) // цикл от 4 до (100-(N_operativ-Ns_operativ)) (97-(N_operativ-Ns_operativ)) значений
	{
		if ((Mas_amplitude_temp[nom_kan][i] > (Mas_amplitude_temp[nom_kan][i + 1] + ADC_porog)) && ((Mas_amplitude_temp[nom_kan][i + 2]) >= (Mas_amplitude_temp[nom_kan][i] + 0)))
		{

			// заполнение 6-ти верхних элементов массивов Mas_amplitude_operativ и Mas_timer_operativ
			for (int8_t j = N_operativ - 1; j >= Ns_operativ; j--) // цикл от (N_operativ-1) до Ns_operativ ((N_operativ-Ns_operativ) значений)
			{
				Mas_amplitude_operativ[nom_kan][j] = Mas_amplitude_temp[nom_kan][i + (j - Ns_operativ)]; // заполнение текущего элемента массива Mas_amplitude_operativ значением из массива Mas_amplitude_temp
				Mas_timer_operativ[nom_kan][j] = Mas_timer_temp[nom_kan][i + (j - Ns_operativ)];		 // заполнение текущего элемента массива Mas_timer_operativ значением из массива Mas_timer_temp
			}

			// заполнение 8-ми нижних элементов массивов Mas_amplitude_operativ и Mas_timer_operativ
			for (int8_t j = 1; j <= Ns_operativ; j++) // цикл от 1 до Ns_operativ (Ns_operativ значений)
			{
				if (i - 4 < j) // если во временном массиве нет значений измерения сигнала
				{
					Mas_amplitude_operativ[nom_kan][Ns_operativ - j] = ADC_virtual_null;				 // заполнение (Ns_operativ+1-j)-го элемента массива Mas_amplitude_operativ значением ADC_virtual_null
					Mas_timer_operativ[nom_kan][Ns_operativ - j] = Mas_timer_temp[nom_kan][i] - 160 * j; // заполнение (Ns_operativ+1-j)-го элемента массива Mas_timer_operativ рассчётным значением, меньшим предыдущего на величину полупериода (160 тактов микроконтроллера)
				}
				else // иначе
				{
					Mas_amplitude_operativ[nom_kan][Ns_operativ - j] = Mas_amplitude_temp[nom_kan][i - j]; // заполнение (13-j)-го элемента массива Mas_amplitude_operativ значением из массива Mas_amplitude_temp
					Mas_timer_operativ[nom_kan][Ns_operativ - j] = Mas_timer_temp[nom_kan][i - j];		   // заполнение (13-j)-го элемента массива Mas_timer_operativ значением из массива Mas_timer_temp
				}
			}

			break; // выход из цикла создания оперативного (урезанного) массива k-го канала
		}
	}

	// обработка ситуации, когда оперативный массив не создан
	if (i == (100 - (N_operativ - Ns_operativ))) // если не был создан оперативный массив для k-го канала
	{
		for (uint8_t j = 0; j < N_operativ; j++) // цикл от 0 до N_operativ-1 (N_operativ значений)
		{
			Mas_timer_operativ[nom_kan][j] = 1000 + 160 * j;
			Mas_amplitude_operativ[nom_kan][j] = ADC_virtual_null;
		}

		Status_error_anemometr = nom_kan + 1; // сохранение статуса ошибки анемометра
	}
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------- Функции сбора данных (начало)
// —————————————
void func_timer_null_point(uint8_t pair, uint8_t Nomer) // функция нахождения точки времени, отстоящей
// на заданную величину от точки теоретического пересечения нуля и записи найденного значения в ячейку массива под номером i
{
	/*int8_t delta; //объявление локальной переменной

	delta=Mas_timer_null_point[0]-Mas_timer_null_point[1]; //присвоить переменной delta значение разницы номеров точек пересечения нуля

		if(delta>0) //если разница номеров точек пересечения нуля больше 0
		{
		Mas_timer[0][Nomer]=Mas_timer_operativ[0][N_operativ-1];
		Mas_timer[1][Nomer]=Mas_timer_operativ[1][N_operativ-1-delta];
		}

		else //если разница номеров точек пересечения нуля меньше 0
		{
		Mas_timer[0][Nomer]=Mas_timer_operativ[0][N_operativ-1-delta];
		Mas_timer[1][Nomer]=Mas_timer_operativ[1][N_operativ-1];
		}


	delta=Mas_timer_null_point[2]-Mas_timer_null_point[3]; //присвоить переменной delta значение разницы номеров точек пересечения нуля

		if(delta>0) //если разница номеров точек пересечения нуля больше 0
		{
		Mas_timer[2][Nomer]=Mas_timer_operativ[2][N_operativ-1];
		Mas_timer[3][Nomer]=Mas_timer_operativ[3][N_operativ-1-delta];
		}

		else //если разница номеров точек пересечения нуля меньше 0
		{
		Mas_timer[2][Nomer]=Mas_timer_operativ[2][N_operativ-1-delta];
		Mas_timer[3][Nomer]=Mas_timer_operativ[3][N_operativ-1];
		}*/
	Mas_timer[pair][Nomer] = Mas_timer_null[pair]; // заполнение массива Mas_timer значением k-го канала для N-го прохода
}
// ———————————

// —————————————
void func_timer_null_point_amplitude_kalibr_usil(uint8_t pair) // функция нахождения точки амплитуды для калибровки усиления, отстоящей на 3 точки вправо от базовой точки амплитуды,
// ближайшей ко времени теоретического пересечения "0" для выбранного канала (pair=0...3)
{
	// for (int8_t i=(N_operativ-6); i>=0; i=i-2) //цикл от (N_operativ-6) до 0
	//{
	// if(Mas_timer_null[pair]>Mas_timer_operativ[pair][i]) //если разница между теоретически рассчитанное значение прохода через "0" больше текущего значения чётной (положительной) точки оперативного массива
	//{
	// Mas_amplitude[pair][0]=Mas_amplitude_operativ[pair][i+5]; //заполнение нулевой ячейки массива Mas_amplitude значением k-го канала для N-го прохода
	// return; //выход из функции
	// }
	//}
	Mas_amplitude[pair][0] = Mas_amplitude_operativ[pair][Mas_timer_null_point[pair]]; // заполнение нулевой ячейки массива Mas_amplitude значением k-го канала
}
// ———————————

// —————————————
void func_timer_null_operativ_mas(uint8_t nom_kan) // функция нахождения наибольшего времени пересечения нуля для выбранного канала (nom_kan=0...3)
{
	int16_t Timer_temp_positive; // объявление локальной переменной для вычисления времени теоретического пересечения нуля для положительных точек
	int16_t Timer_temp_negative; // объявление локальной переменной для вычисления времени теоретического пересечения нуля для отрицательных точек
	int16_t Timer_temp_sred;	 // объявление локальной переменной для вычисления среднего времени теоретического пересечения нуля
	int16_t Timer_temp_max;		 // объявление локальной переменной для вычисления наибольшего времени теоретического пересечения нуля

	Timer_temp_sred = -32767; // начальное значение переменной
	Timer_temp_max = -32767;  // начальное значение переменной
	// Mas_timer_null[nom_kan]=-32767; //начальное значение прохода через "0" для заданного канала

	for (uint8_t i = (N_operativ - 1); i > 2; i = i - 2) // цикл от (N_operativ-1) до 3
	{

		if (((Mas_amplitude_operativ[nom_kan][i] < (ADC_virtual_null - 4)) && (Mas_amplitude_operativ[nom_kan][i - 2] > (Mas_amplitude_operativ[nom_kan][i] + 2))) && ((Mas_amplitude_operativ[nom_kan][i - 1] > (ADC_virtual_null + 4)) && (Mas_amplitude_operativ[nom_kan][i - 3] < (Mas_amplitude_operativ[nom_kan][i - 1] - 2))))
		// если 1-я точка амплитуды отрицательного импульса минимум на 5 единиц меньше значения виртального нуля АЦП (в 8-ми разрядном коде)
		// и если 3-я точка амплитуды отрицательного импульса больше амплитуды 1-го импульса минимум на 3 единицы 8-разрядного кода АЦП
		// и если 2-я точка амплитуды положительного импульса минимум на 5 единиц больше значения виртального нуля АЦП (в 8-ми разрядном коде)
		// и если 4-я точка амплитуды положительного импульса меньше амплитуды текущего импульса минимум на 3 единицы 8-разрядного кода АЦП

		{
			Timer_temp_negative = (int16_t)(round((Mas_timer_operativ[nom_kan][i] * (double)(ADC_virtual_null - Mas_amplitude_operativ[nom_kan][i - 2]) - Mas_timer_operativ[nom_kan][i - 2] * (double)(ADC_virtual_null - Mas_amplitude_operativ[nom_kan][i])) / (double)(Mas_amplitude_operativ[nom_kan][i] - Mas_amplitude_operativ[nom_kan][i - 2])));
			// вычисление текущего теоретически рассчитанного значения прохода через "0" отрицательных точек заданного канала
			Timer_temp_positive = (int16_t)(round((Mas_timer_operativ[nom_kan][i - 1] * (double)(ADC_virtual_null - Mas_amplitude_operativ[nom_kan][i - 3]) - Mas_timer_operativ[nom_kan][i - 3] * (double)(ADC_virtual_null - Mas_amplitude_operativ[nom_kan][i - 1])) / (double)(Mas_amplitude_operativ[nom_kan][i - 1] - Mas_amplitude_operativ[nom_kan][i - 3])));
			// вычисление текущего теоретически рассчитанного значения прохода через "0" положительных точек для заданного канала

			Timer_temp_sred = (Timer_temp_negative + Timer_temp_positive) / 2; // сохранение среднего значения времени теоретического пересечения нуля

			if (Timer_temp_sred > Timer_temp_max) // если текущее значение Timer_temp_sred больше предыдущих значений
			{
				Timer_temp_max = Timer_temp_sred;  // сохранение нового наибольшего значения теоретически рассчитанного значения Timer_temp_max
				Mas_timer_null_point[nom_kan] = i; // сохранение нового порядкового номера точки теоретически расчитанного времени пересечения нуля текущего канала
				// Mas_timer[nomer_kanala][Nomer]=i;  //сохранение нового порядкового номера точки амплитуды для теоретически расчитанного времени пересечения нуля текущего канала
			}
		}
	}
	// Mas_timer_null[nom_kan]=Timer_temp_max; //сохранение среднего значения наибольшего времени теоретического пересечения нуля текущего канала
	Mas_timer_null[nom_kan] = Mas_timer_operativ[nom_kan][Mas_timer_null_point[nom_kan]]; // сохранение среднего значения наибольшего времени теоретического пересечения нуля текущего канала
}
// —————————————

// —————————————
void func_temp_sbor_dannyh(void) // функция временного сбора данных таймера-счётчика в массив
{
	RTC_OFF;		 // запрет прерывания счетчика реального времени RTC по совпадению
	generator();	 // вызов функции запуска одного периода импульса частотой 200 кГц (длительность полупериода - 1,25 мкс)
	_delay_us(200);	 // задержка 200 мкс (мёртвое время)
	Timer_ON;		 // включение таймера счётчика без деления тактовой частоты
	TCC0_CNT = 0;	 // обнуление таймера счётчика
	Comparator_ON;	 // разрешение работы компаратора
	_delay_us(3000); // задержка 3 мс
	RTC_ON;			 // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
}
// ———————————

// —————————————
void func_vyvod_test_ADC(void) // функция вывода тестового измерения ЦАП
{

	setpos(0, 0);										   // устанавливаем курсор в начальное положение первой строки
	str_lcd("k0:");										   // выводим надпись "k0:"
	sendcharlcd((uint16_t)(dT_k0_k1 / 10000) % 10 + 0x30); // вывод
	sendcharlcd((uint16_t)(dT_k0_k1 / 1000) % 10 + 0x30);  // вывод
	sendcharlcd((uint16_t)(dT_k0_k1 / 100) % 10 + 0x30);   // вывод
	sendcharlcd((uint16_t)(dT_k0_k1 / 10) % 10 + 0x30);	   // вывод
	sendcharlcd((uint16_t)(dT_k0_k1 / 1) % 10 + 0x30);	   // вывод
	str_lcd(" k2:");									   // выводим надпись " k2:"
	sendcharlcd((uint16_t)(dT_k2_k3 / 10000) % 10 + 0x30); // вывод
	sendcharlcd((uint16_t)(dT_k2_k3 / 1000) % 10 + 0x30);  // вывод
	sendcharlcd((uint16_t)(dT_k2_k3 / 100) % 10 + 0x30);   // вывод
	sendcharlcd((uint16_t)(dT_k2_k3 / 10) % 10 + 0x30);	   // вывод
	sendcharlcd((uint16_t)(dT_k2_k3 / 1) % 10 + 0x30);	   // вывод

	_delay_ms(10000); // задержка 10 с
}
// —————————————

// —————————————
void func_null_Mas_temp(void) // функция обнуления временных массивов
{
	for (uint8_t n = 0; n < 4; n++) // цикл по каналам от 0 до 3
	{
		for (uint8_t i = 0; i < 104; i++) // цикл от 0 до 103 (обнуление массива)
		{
			// Mas_timer_temp[n][i]=0; //обнуление массива Mas_timer_temp
			Mas_amplitude_temp[n][i] = 0; // обнуление массива Mas_amplitude_temp
		}
	}
}
// —————————————

// —————————————
void func_baze_sbor_dannyh(uint8_t N) // функция базового сбора данных с указанием количества проходов N
{
	Sum_error = 0;				// обнуление переменной счётчика ошибок приёма сигнала
	Status_error_anemometr = 0; // обнуление ошибки анемометра
	uint8_t tempKU[4];
	uint16_t threshold = ADC_porog;

	for (uint8_t i = 0; i < 4; i++) // threshold and KU changings are from experiments
	{
		if (Vprevious > 350)
		{
			if (Mas_previousPD[i] < 100)
			{
				threshold = ADC_porog + 15;
				tempKU[i] = Mas_previousPD[i];
			}
			else
			{
				threshold += 10;
				tempKU[i] = 100;
			}
		}
		else if (Vprevious > 250)
		{
			tempKU[i] = Mas_basedPD[i] + Mas_PD_30mps_increment;
			threshold = ADC_porog + 10;
		}
		else if (Vprevious > 200)
			tempKU[i] = Mas_basedPD[i] + Mas_PD_25mps_increment;
		else
			tempKU[i] = Mas_basedPD[i];
	}

	for (int8_t i = 0; i < N; i++) // цикл от 0 до N-1
	{
		func_null_Mas_temp(); // вызов функции обнуления временных массивов

		for (uint8_t k = 0; k < 4; k++) // цикл от 0 до 3 (по 4-м каналам)
		{
			Potentiometr_set(tempKU[k]); // вызов функции установки потенциометра c извлечением значения k-го канала (PD задаёт число от 0 до 255, что примерно соответствует сопротивлению R(кОм) = 0,2*PD)
			kanal_select(k);			 // вызов функции включения k-го канала
			func_temp_sbor_dannyh();	 // вызов функции временного сбора данных таймера-счётчика в массив
		}

		for (uint8_t k = 0; k < 4; k++) // цикл от 0 до 3 (по 4-м каналам)
		{
			for (uint8_t j = 0; j < 10; j++)
			{
				Status_error_anemometr = 0;
				func_operativ_mas(k, threshold); // вызов функции создания оперативного (урезанного) массива для выбранного канала (nom_kan=0...3) с пороговым значения АЦП ADC_porog (в 8-ми разрядном коде)
				if (Status_error_anemometr == 0)
					break;
			}
		}

		if (Status_error_anemometr > 0) // если статус ошибки анемометра больше 0
		{
			Sum_error++;		 // инкремент переменной счётчика ошибок принятых данных
			if (Sum_error == 50) // если число счётчика ошибок принятых данных достигло 50
			{
				return; // выход из функции
			}
			Status_error_anemometr = 0; // обнуление ошибки анемометра
			if (Sum_error > 35)
			{
				for (uint8_t i = 0; i < 4; i++)
				{
					tempKU[i] += 10;
				}
			}
			i--; // декремент переменной i (ещё раз сделать i-ю выборку)
		}

		if (N > 1)
		{
			for (uint8_t k = 0; k < 4; k++) // цикл от 0 до 3 (по 4-м каналам)
			{
				func_timer_null_operativ_mas(k); // вызов функции нахождения наибольшего времени пересечения нуля для выбранного канала (k=0...3)
				func_timer_null_point(k, i);	 // вызов функции нахождения точки времени, отстоящей на заданную величину от точки
				// теоретического пересечения нуля и записи найденного значения в ячейку массива под номером i
			}
		}
	}

	for (uint8_t i = 0; i < 4; i++)
	{
		Mas_previousPD[i] = tempKU[i];
	}
}
// —————————————
//---------------------------------------------------------------------------------------------------------------------------- Функции сбора данных (конец)

//---------------------------------------------------------------------------------------------------------------------------- Функции математической обработки (начало)
// —————————————
void func_matstat_integral_sred(void) // функция вычисления среднего значения интегральных массивов
{
	int32_t matstat_Sum_integral_sred;	// объявление локальной переменной для хранения суммы значений средних значений времени
	int32_t matstat_Sum_integral_delta; // объявление локальной переменной для хранения суммы значений средних значений разницы времени

	matstat_Sum_integral_sred = 0;	// matstat_Sum_integral_sred
	matstat_Sum_integral_delta = 0; // обнуление переменной matstat_Sum_integral_sred_delta

	for (uint8_t i = 0; i < 10; i++) // цикл от 0 до 9
	{
		matstat_Sum_integral_sred = matstat_Sum_integral_sred + Mas_timer_integral_X[0][i];	  // вычисление текущей суммы элементов средних значений времени по оси X
		matstat_Sum_integral_delta = matstat_Sum_integral_delta + Mas_timer_integral_X[1][i]; // вычисление текущей суммы элементов средних значений разницы времени по оси X
	}
	dT_k0_sred = (uint16_t)(round(0.1 * (double)matstat_Sum_integral_sred)); // находим среднее значение времени канала 1
	dT_k0_k1 = (uint16_t)(round(0.1 * (double)matstat_Sum_integral_delta));	 // находим среднее значение разницы времени канала 1 и канала 2

	matstat_Sum_integral_sred = 0;	// matstat_Sum_integral_sred
	matstat_Sum_integral_delta = 0; // обнуление переменной matstat_Sum_integral_sred_delta

	for (uint8_t i = 0; i < 10; i++) // цикл от 0 до 9
	{
		matstat_Sum_integral_sred = matstat_Sum_integral_sred + Mas_timer_integral_Y[0][i];	  // вычисление текущей суммы элементов средних значений времени по оси Y
		matstat_Sum_integral_delta = matstat_Sum_integral_delta + Mas_timer_integral_Y[1][i]; // вычисление текущей суммы элементов средних значений разницы времени по оси Y
	}
	dT_k2_sred = (uint16_t)(round(0.1 * (double)matstat_Sum_integral_sred)); // находим среднее значение времени канала 3
	dT_k2_k3 = (uint16_t)(round(0.1 * (double)matstat_Sum_integral_delta));	 // находим среднее значение разницы времени канала 3 и канала 4
}
// —————————————

// —————————————
void func_matstat_sred(uint8_t N) // функция вычисления среднего значения из N измерений
{
	int16_t Mas_matstat_x1[N]; // объявление локального массива для хранения разницы времён канала 1 и канала 2
	int16_t Mas_matstat_x2[N]; // объявление локального массива для хранения времён канала 1
	int16_t Mas_matstat_y1[N]; // объявление локального массива для хранения разницы времён канала 3 и канала 4
	int16_t Mas_matstat_y2[N]; // объявление локального массива для хранения времён канала 3
	int32_t matstat_Sum_x1;	   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_x1
	int32_t matstat_Sum_x2;	   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_x2
	int32_t matstat_Sum_y1;	   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_y1
	int32_t matstat_Sum_y2;	   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_y2

	matstat_Sum_x1 = 0; // обнуление переменной matstat_Sum_x1
	matstat_Sum_x2 = 0; // обнуление переменной matstat_Sum_x2
	matstat_Sum_y1 = 0; // обнуление переменной matstat_Sum_y1
	matstat_Sum_y2 = 0; // обнуление переменной matstat_Sum_y2

	for (uint8_t i = 0; i < N; i++) // цикл от 0 до N-1
	{
		Mas_matstat_x1[i] = Mas_timer[0][i] - Mas_timer[1][i]; // заполнение массива статистики значениями разницы времён канала 1 и канала 2
		Mas_matstat_x2[i] = Mas_timer[0][i];				   // заполнение массива статистики значениями времён канала 1
		matstat_Sum_x1 = matstat_Sum_x1 + Mas_matstat_x1[i];   // вычисление текущей суммы элементов массива
		matstat_Sum_x2 = matstat_Sum_x2 + Mas_matstat_x2[i];   // вычисление текущей суммы элементов массива
		Mas_matstat_y1[i] = Mas_timer[2][i] - Mas_timer[3][i]; // заполнение массива статистики значениями разницы времён канала 3 и канала 4
		Mas_matstat_y2[i] = Mas_timer[2][i];				   // заполнение массива статистики значениями времён канала 3
		matstat_Sum_y1 = matstat_Sum_y1 + Mas_matstat_y1[i];   // вычисление текущей суммы элементов массива
		matstat_Sum_y2 = matstat_Sum_y2 + Mas_matstat_y2[i];   // вычисление текущей суммы элементов массива
	}

	dT_k0_k1 = (int16_t)(round((double)(matstat_Sum_x1) / (double)(N)));   // находим среднее значение разницы времён канала 1 и канала 2 массива из N элементов
	dT_k0_sred = (int16_t)(round((double)(matstat_Sum_x2) / (double)(N))); // находим среднее значение времён канала 1 массива из N элементов

	dT_k2_k3 = (int16_t)(round((double)(matstat_Sum_y1) / (double)(N)));   // находим среднее значение разницы времён канала 3 и канала 4 массива из N элементов
	dT_k2_sred = (int16_t)(round((double)(matstat_Sum_y2) / (double)(N))); // находим среднее значение времён канала 3 массива из N элементов
}
// —————————————

/*
//—————————————
void func_matstat_kalibr(void) //функция вычисления среднего значения разницы времён для оси Х и оси У (N_prohodov измерений)
{
int16_t Mas_matstat_x[N_prohodov]; //объявление локального массива для хранения разницы времён канала 1 и канала 2 для оси Х
int16_t Mas_matstat_y[N_prohodov]; //объявление локального массива для хранения разницы времён канала 3 и канала 4 для оси Y
int32_t matstat_Sum_x; //объявление локальной переменной для хранения суммы значений массива Mas_matstat_x
int32_t matstat_Sum_y; //объявление локальной переменной для хранения суммы значений массива Mas_matstat_y
matstat_Sum_x=0; //обнуление переменной matstat_Sum_x
matstat_Sum_y=0; //обнуление переменной matstat_Sum_y

	for (uint8_t i=0; i<N_prohodov; i++) //цикл от 0 до (N_prohodov-1)
	{
	Mas_matstat_x[i]=Mas_timer[0][i]-Mas_timer[1][i]; //заполнение массива статистики значениями разницы времён канала 1 и канала 2
	matstat_Sum_x=matstat_Sum_x+Mas_matstat_x[i]; //вычисление текущей суммы элементов массива
	Mas_matstat_y[i]=Mas_timer[2][i]-Mas_timer[3][i]; //заполнение массива статистики значениями разницы времён канала 3 и канала 4
	matstat_Sum_y=matstat_Sum_y+Mas_matstat_y[i]; //вычисление текущей суммы элементов массива
	}
dT_k0_k1_null=(int16_t)(round((double)(matstat_Sum_x)/(double)(N_prohodov))); //находим среднее значение разницы времён канала 1 и канала 2 массива из N_prohodov элементов
dT_k2_k3_null=(int16_t)(round((double)(matstat_Sum_y)/(double)(N_prohodov))); //находим среднее значение разницы времён канала 3 и канала 4 массива из N_prohodov элементов
}
//—————————————
*/

/*
//—————————————
void func_matstat_amplituda (int8_t Nomer_impulsa) //функция измерения средней амплитуды по 4-м каналам в 8-битном коде АЦП, параметром выступает номер импульса
{
Mas_sred_amplitude[0]=0; //обнуление элемента массива для хранения средней амплитуды 1-го канала
Mas_sred_amplitude[1]=0; //обнуление элемента массива для хранения средней амплитуды 2-го канала
Mas_sred_amplitude[2]=0; //обнуление элемента массива для хранения средней амплитуды 3-го канала
Mas_sred_amplitude[3]=0; //обнуление элемента массива для хранения средней амплитуды 4-го канала
	for (uint8_t j=0; j<N_prohodov; j++) //цикл от 0 до N_prohodov-1
	{
	Mas_sred_amplitude[0]=Mas_sred_amplitude[0]+Mas_amplitude[0][j]; //суммирование амплитуд 1-го канала
	Mas_sred_amplitude[1]=Mas_sred_amplitude[1]+Mas_amplitude[1][j]; //суммирование амплитуд 2-го канала
	Mas_sred_amplitude[2]=Mas_sred_amplitude[2]+Mas_amplitude[2][j]; //суммирование амплитуд 3-го канала
	Mas_sred_amplitude[3]=Mas_sred_amplitude[3]+Mas_amplitude[3][j]; //суммирование амплитуд 1-го канала
	}
Mas_sred_amplitude[0]=(uint16_t)((round(100*(double)(Mas_sred_amplitude[0])/(double)(N_prohodov)))); //вычисление средней амплитуды 1-го канала
Mas_sred_amplitude[1]=(uint16_t)((round(100*(double)(Mas_sred_amplitude[1])/(double)(N_prohodov)))); //вычисление средней амплитуды 2-го канала
Mas_sred_amplitude[2]=(uint16_t)((round(100*(double)(Mas_sred_amplitude[2])/(double)(N_prohodov)))); //вычисление средней амплитуды 3-го канала
Mas_sred_amplitude[3]=(uint16_t)((round(100*(double)(Mas_sred_amplitude[3])/(double)(N_prohodov)))); //вычисление средней амплитуды 4-го канала

Mas_amplitude_point[0][Nomer_impulsa-1]=Mas_sred_amplitude[0]; //сохранение 1-й амплитуды 1-го канала
Mas_amplitude_point[1][Nomer_impulsa-1]=Mas_sred_amplitude[1]; //сохранение 1-й амплитуды 2-го канала
Mas_amplitude_point[2][Nomer_impulsa-1]=Mas_sred_amplitude[2]; //сохранение 1-й амплитуды 3-го канала
Mas_amplitude_point[3][Nomer_impulsa-1]=Mas_sred_amplitude[3]; //сохранение 1-й амплитуды 4-го канала
}
//—————————————
*/

// —————————————
void func_matstat_lux_X(int16_t Metka) // функция преобразования массива по оси X из N_prohodov элементов в массив, меньший на dN_prohodov элементов с наибольшим отклонением от среднего значения (с целью исключения промахов измерения),
// и последующим пересчётом среднего значения в меньшем массиве. В массиве есть ограничение, необходимо задать число (Metka), которого не должно быть среди элементов массива
{
	int8_t Mas_index[dN_prohodov];	   // объявление локального массива для хранения индексов элементов с максимальным отклонением от среднего значения
	int16_t Mas_matstat_1[N_prohodov]; // объявление локального массива для хранения разницы времён канала 1 и канала 2
	int16_t Mas_matstat_2[N_prohodov]; // объявление локального массива для хранения времён канала 1
	int32_t matstat_Sum_1;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_1
	int32_t matstat_Sum_2;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_2
	int16_t matstat_max_1;			   // переменная для хранения максимального значения массива Mas_matstat_1

	matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		Mas_matstat_1[i] = Mas_timer[0][i] - Mas_timer[1][i]; // заполнение массива статистики значениями разницы времён канала 1 и канала 2
		Mas_matstat_2[i] = Mas_timer[0][i];					  // заполнение массива статистики значениями времён канала 1
		matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i];	  // вычисление текущей суммы элементов массива
		matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i];	  // вычисление текущей суммы элементов массива
	}
	dT_k0_k1 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov))); // находим среднее значение разницы времён канала 1 и канала 2 массива из N_prohodov элементов
	for (uint8_t j = 0; j < dN_prohodov; j++)									 // цикл от 0 до (dN_prohodov-1)
	{
		matstat_max_1 = 0;						 // выставляем минимально возможное значение для matstat_max
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				if (abs(dT_k0_k1 - Mas_matstat_1[i]) >= matstat_max_1) // если отклонение от среднего значения в массиве больше либо равно текущему максимуму
				{
					matstat_max_1 = abs(dT_k0_k1 - Mas_matstat_1[i]); // перезапись текущего максимума
					Mas_index[j] = i;								  // перезапись индекса элемента массива текущего максимума
				}
			}
		}
		Mas_matstat_1[Mas_index[j]] = Metka;	 // присвоение элементу значения Metka (элемент с "меткой")
		matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i]; // вычисление текущей суммы элементов массива
			}
		}
		dT_k0_k1 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov - 1 - j))); // находим среднее значение разницы времён канала 1 и канала 2 массива из (N-dN) элементов
	}
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
		{
			matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i]; // вычисление текущей суммы элементов массива
		}
	}
	dT_k0_sred = (int16_t)(round((double)(matstat_Sum_2) / (double)(N_prohodov - dN_prohodov))); // находим среднее значение времён канала 1 массива из (N_prohodov-dN_prohodov) элементов
}
// —————————————

// —————————————
void func_matstat_lux_Y(int16_t Metka) // функция преобразования массива по оси Y из N_prohodov элементов в массив, меньший на dN_prohodov элементов с наибольшим отклонением от среднего значения (с целью исключения промахов измерения),
// и последующим пересчётом среднего значения в меньшем массиве. В массиве есть ограничение, необходимо задать число (Metka), которого не должно быть среди элементов массива
{
	int8_t Mas_index[dN_prohodov];	   // объявление локального массива для хранения индексов элементов с максимальным отклонением от среднего значения
	int16_t Mas_matstat_1[N_prohodov]; // объявление локального массива для хранения разницы времён канала 3 и канала 4
	int16_t Mas_matstat_2[N_prohodov]; // объявление локального массива для хранения времён канала 3
	int32_t matstat_Sum_1;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_1
	int32_t matstat_Sum_2;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_2
	int16_t matstat_max_1;			   // переменная для хранения максимального значения массива Mas_matstat_1

	matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		Mas_matstat_1[i] = Mas_timer[2][i] - Mas_timer[3][i]; // заполнение массива статистики значениями разницы времён канала 3 и канала 4
		Mas_matstat_2[i] = Mas_timer[2][i];					  // заполнение массива статистики значениями времён канала 3
		matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i];	  // вычисление текущей суммы элементов массива
		matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i];	  // вычисление текущей суммы элементов массива
	}
	dT_k2_k3 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov))); // находим среднее значение разницы времён канала 3 и канала 4 массива из N_prohodov элементов
	for (uint8_t j = 0; j < dN_prohodov; j++)									 // цикл от 0 до (dN_prohodov-1)
	{
		matstat_max_1 = 0;						 // выставляем минимально возможное значение для matstat_max
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				if (abs(dT_k2_k3 - Mas_matstat_1[i]) >= matstat_max_1) // если отклонение от среднего значения в массиве больше либо равно текущему максимуму
				{
					matstat_max_1 = abs(dT_k2_k3 - Mas_matstat_1[i]); // перезапись текущего максимума
					Mas_index[j] = i;								  // перезапись индекса элемента массива текущего максимума
				}
			}
		}
		Mas_matstat_1[Mas_index[j]] = Metka;	 // присвоение элементу значения Metka (элемент с "меткой")
		matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i]; // вычисление текущей суммы элементов массива
			}
		}
		dT_k2_k3 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov - 1 - j))); // находим среднее значение разницы времён канала 3 и канала 4 массива из (N-dN) элементов
	}
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
		{
			matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i]; // вычисление текущей суммы элементов массива
		}
	}
	dT_k2_sred = (int16_t)(round((double)(matstat_Sum_2) / (double)(N_prohodov - dN_prohodov))); // находим среднее значение времён канала 3 массива из (N_prohodov-dN_prohodov) элементов
}
// —————————————

// —————————————
void func_matstat_lux_usil_k0_k2(int16_t Metka) // функция преобразования массива по оси X из N_prohodov элементов в массив, меньший на dN_prohodov элементов с наибольшим отклонением от среднего значения (с целью исключения промахов измерения),
// и последующим пересчётом среднего значения в меньшем массиве. В массиве есть ограничение, необходимо задать число (Metka), которого не должно быть среди элементов массива
{
	int8_t Mas_index[dN_prohodov];	   // объявление локального массива для хранения индексов элементов с максимальным отклонением от среднего значения
	int16_t Mas_matstat_1[N_prohodov]; // объявление локального массива для хранения разницы времён канала 1 и канала 2
	int16_t Mas_matstat_2[N_prohodov]; // объявление локального массива для хранения времён канала 1
	int32_t matstat_Sum_1;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_1
	int32_t matstat_Sum_2;			   // объявление локальной переменной для хранения суммы значений массива Mas_matstat_2
	int16_t matstat_max_1;			   // переменная для хранения максимального значения массива Mas_matstat_1

	matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		Mas_matstat_1[i] = Mas_timer[0][i] - Mas_timer[1][i]; // заполнение массива статистики значениями разницы времён канала 1 и канала 2
		Mas_matstat_2[i] = Mas_timer[0][i];					  // заполнение массива статистики значениями времён канала 1
		matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i];	  // вычисление текущей суммы элементов массива
		matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i];	  // вычисление текущей суммы элементов массива
	}
	dT_k0_k1 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov))); // находим среднее значение разницы времён канала 1 и канала 2 массива из N_prohodov элементов
	for (uint8_t j = 0; j < dN_prohodov; j++)									 // цикл от 0 до (dN_prohodov-1)
	{
		matstat_max_1 = 0;						 // выставляем минимально возможное значение для matstat_max
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				if (abs(dT_k0_k1 - Mas_matstat_1[i]) >= matstat_max_1) // если отклонение от среднего значения в массиве больше либо равно текущему максимуму
				{
					matstat_max_1 = abs(dT_k0_k1 - Mas_matstat_1[i]); // перезапись текущего максимума
					Mas_index[j] = i;								  // перезапись индекса элемента массива текущего максимума
				}
			}
		}
		Mas_matstat_1[Mas_index[j]] = Metka;	 // присвоение элементу значения Metka (элемент с "меткой")
		matstat_Sum_1 = 0;						 // обнуление переменной matstat_Sum_1
		for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
		{
			if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
			{
				matstat_Sum_1 = matstat_Sum_1 + Mas_matstat_1[i]; // вычисление текущей суммы элементов массива
			}
		}
		dT_k0_k1 = (int16_t)(round((double)(matstat_Sum_1) / (double)(N_prohodov - 1 - j))); // находим среднее значение разницы времён канала 1 и канала 2 массива из (N-dN) элементов
	}
	matstat_Sum_2 = 0;						 // обнуление переменной matstat_Sum_2
	for (uint8_t i = 0; i < N_prohodov; i++) // цикл от 0 до (N_prohodov-1)
	{
		if (Mas_matstat_1[i] != Metka) // если текущий элемент массива не равен Metka (элемент без "метки")
		{
			matstat_Sum_2 = matstat_Sum_2 + Mas_matstat_2[i]; // вычисление текущей суммы элементов массива
		}
	}
	dT_k0_sred = (int16_t)(round((double)(matstat_Sum_2) / (double)(N_prohodov - dN_prohodov))); // находим среднее значение времён канала 1 массива из (N_prohodov-dN_prohodov) элементов
}
// —————————————

// —————————————
void func_V_calculation(void) // функция вычисления скорости и направления ветра
{
	double Koef_kor; // объявление переменной для задания коэффициента коррекции скорости ветра

	Vx = 5000 * Sx_kal / Cos_a / (Tx_kal + (double)(dT_k0_sred) / 6.4) / (Tx_kal + (double)(dT_k0_sred) / 6.4 - (double)(dT_k0_k1) / 6.4) * ((double)(dT_k0_k1_null) / 6.4 - (double)(dT_k0_k1) / 6.4);	  // формула вычисления скорости ветра (в дм/с) для оси X
	Cx = 5000 * Sx_kal / (Tx_kal + (double)(dT_k0_sred) / 6.4) / (Tx_kal + (double)(dT_k0_sred) / 6.4 - (double)(dT_k0_k1) / 6.4) * (2 * Tx + 2 * (double)(dT_k0_sred) / 6.4 - (double)(dT_k0_k1) / 6.4); // формула вычисления скорости ультразвука (в дм/с) для оси X

	Vy = 5000 * Sy_kal / Cos_a / (Ty_kal + (double)(dT_k2_sred) / 6.4) / (Ty_kal + (double)(dT_k2_sred) / 6.4 - (double)(dT_k2_k3) / 6.4) * ((double)(dT_k2_k3_null) / 6.4 - (double)(dT_k2_k3) / 6.4);	  // формула вычисления скорости ветра (в дм/с) для оси Y
	Cy = 5000 * Sy_kal / (Ty_kal + (double)(dT_k2_sred) / 6.4) / (Ty_kal + (double)(dT_k2_sred) / 6.4 - (double)(dT_k2_k3) / 6.4) * (2 * Ty + 2 * (double)(dT_k2_sred) / 6.4 - (double)(dT_k2_k3) / 6.4); // формула вычисления скорости ультразвука (в дм/с) для оси Y

	Koef_kor = 1 - 0.04 * (sin(2 * atan2(Vy, Vx))) * (sin(2 * atan2(Vy, Vx))) * (sin(2 * atan2(Vy, Vx))) * (sin(2 * atan2(Vy, Vx))); // рассчёт коэффициента коррекции скорости ветра
	// Koef_kor=1; //сброс коэффициента коррекции скорости ветра

	Vx = Vx * Koef_kor;			 // вычисление скорректированной скорости ветра для оси X
	Vy = Vy * Koef_kor;			 // вычисление скорректированной скорости ветра для оси Y
	V = sqrt(Vx * Vx + Vy * Vy); // вычисление результирующей скорости ветра

	Napr = round(180 / M_PI * atan2(Vy, Vx)); // рассчёт направления скорости ветра
	if (Napr < 0)							  // если значение направления ветра в градусах получилось меньше 0
	{
		// Napr=360+Napr; //к результату прибавим 360
		Napr = -Napr; // присвоение результата со знаком минус
	}
	else // если результат положительный
	{
		Napr = 360 - Napr; // вычитание результата от 360
	}

	Vprevious = V;
}
// —————————————
//---------------------------------------------------------------------------------------------------------------------------- Функции математической обработки (конец)

// —————————————
void func_skorost(uint8_t N) // функция скорости ветра в дм/с с параметром выбора режима ("0"- нормальный, "1"- быстрый, "2"- медленный режим)
{
	switch (N)
	{
	case 0x00:			 // если выбран медленный режим работы анемометра
		N_prohodov = 16; // задание количества проходов в нормальном режиме работы анемометра
		break;

	case 0x01:			 // если выбран быстрый режим работы анемометра
		N_prohodov = 12; // задание количества проходов в быстром режиме работы анемометра
		break;

	case 0x02:			// если выбран нормальный режим работы анемометра
		N_prohodov = 8; // задание количества проходов в медленном режиме работы анемометра
		break;
	}

	for (uint8_t i = 0; i < 10; i++) // цикл от 0 до 9
	{
		func_baze_sbor_dannyh(N_prohodov); // вызов функции базового сбора данных
		if (Status_error_anemometr > 0)	   // если значение статуса ошибки анемометра не равно "0"
		{
			break; // выход из цикла
		}
		func_matstat_lux_X(32767); // вызов функции преобразования массива по оси X из N_prohodov элементов
		func_matstat_lux_Y(32767); // вызов функции преобразования массива по оси Y из N_prohodov элементов

		Mas_timer_integral_X[0][i] = dT_k0_sred; // запись среднего значения времени по оси X
		Mas_timer_integral_X[1][i] = dT_k0_k1;	 // запись среднего значения разницы времени по оси X
		Mas_timer_integral_Y[0][i] = dT_k2_sred; // запись среднего значения времени по оси Y
		Mas_timer_integral_Y[1][i] = dT_k2_k3;	 // запись среднего значения разницы времени по оси Y
	}
	if (Status_error_anemometr == 0) // если значение статуса ошибки анемометра равно "0"
	{
		func_matstat_integral_sred(); // вызов функции вычисления среднего значения интегральных массивов
		func_V_calculation();		  // вызов функции вычисления скорости и направления ветра
	}
}
// —————————————

// —————————————
void func_skorost_N(uint8_t N) // функция вычисления скорости ветра (в дм/с) N раз с усреднением
{
	double Sum_Vx = 0;				// объявление локальной переменной для хранения симмы скорости ветра по оси X
	double Sum_Vy = 0;				// объявление локальной переменной для хранения симмы скорости ветра по оси Y
	for (uint8_t i = 0; i < N; i++) // цикл от 0 до 9
	{
		func_skorost(0);	  // вызов функции вычисления скорости ветра
		Sum_Vx = Sum_Vx + Vx; // суммирование скорости ветра по оси X
		Sum_Vx = Sum_Vy + Vy; // суммирование скорости ветра по оси Y
	}
	Vx = Sum_Vx / N; // вычисление средней скорости ветра по оси X
	Vy = Sum_Vy / N; // вычисление средней скорости ветра по оси Y
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------- Функции калибровки (начало)
// —————————————
void func_kalibrovka_usil(void) // функция калибровки усиления для 4-х каналов
{
	uint8_t Sum; // объявление локальной переменной для хранения суммы

	if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
	{
		interrupt_button_OFF; // запрет прерываний по нажатию кнопок
	}

	Status_error_anemometr = 0; // обнуление статуса ошибки связи с анемометром

	//---------------------------------------------------------------------------------------------------------------------------- Калибровка усиления сигнала (начало)
	for (uint8_t k = 0; k < 4; k++) // цикл для 4-х каналов
	{
		kanal_select(k); // вызов функции включения k-го канала

		for (uint16_t KUL = 0; KUL < 256; KUL++) // цикл от 0 до 255 (число установок потенциометра)
		{
			Potentiometr_set(KUL);		// вызов функции установки потенциометра cо значением KUL
			Status_error_anemometr = 0; // обнуление статуса ошибки связи с анемометром
			Sum = 0;

			for (uint8_t n = 0; n < 30; n++) // цикл от 0 до 29 (число измерений)
			{
				func_temp_sbor_dannyh();		// вызов функции временного сбора данных таймера-счётчика в массив
				if (Status_error_anemometr > 0) // если статус ошибки анемометра больше 0
				{
					return; // выход из функции калибровки
				}
				_delay_ms(3); // задержка 3 мс

				func_operativ_mas(k, ADC_amplitude_kalibr); // вызов функции создания оперативного (урезанного) массива для выбранного канала (nom_kan=0...3) с пороговым значения АЦП ADC_amplitude_kalibr (в 8-ми разрядном коде)
				////func_timer_null_operativ_mas_kalibr_usil(k); //функция нахождения наибольшего времени пересечения нуля для выбранного канала (k=0...3)
				func_timer_null_operativ_mas(k); // вызов функции нахождения наибольшего времени пересечения нуля для выбранного канала (k=0...3)
				// func_timer_null_point_amplitude_kalibr_usil(k); //вызов функции нахождения точки амплитуды для калибровки усиления, отстоящей на 3 точки вправо от базовой точки амплитуды,
				// ближайшей ко времени теоретического пересечения "0" для выбранного канала (k=0...3)
				Mas_amplitude[k][0] = Mas_amplitude_operativ[k][Mas_timer_null_point[k]]; // заполнение нулевой ячейки массива Mas_amplitude значением k-го канала

				if (Mas_amplitude[k][0] < 16) // если значение нулевой ячейки массива Mas_amplitude k-го канала меньше 16
				{
					Sum++; // инкремент значения Sum
				}
			}

			if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
			{
				clearlcd();									// очистка дисплея
				setpos(0, 0);								// устанавливаем курсор в начальное положение первой строки
				str_lcd("Ka»ёІpoієa єaЅa»a ");				// выводим надпись "Калибровка канала "
				sendcharlcd((uint16_t)(k + 1) % 10 + 0x30); // Преобразуем число в код числа
				str_lcd(" ");								// выводим надпись " "

				str_lcd("Koг ѕpёµјa: ");										  // выводим надпись "Код приёма: "
				sendcharlcd((uint16_t)(Status_error_anemometr / 10) % 10 + 0x30); // Преобразуем число в код числа
				sendcharlcd((uint16_t)(Status_error_anemometr / 1) % 10 + 0x30);  // Преобразуем число в код числа
				str_lcd("      ");												  // выводим надпись "      "

				setpos(0, 1);									// устанавливаем курсор в начальное положение 2-й строки
				str_lcd("©cїaЅoієa ·ЅaА.: ");					// выводим надпись "Установка знач.: "
				sendcharlcd((uint16_t)(KUL / 100) % 10 + 0x30); // Преобразуем число в код числа
				sendcharlcd((uint16_t)(KUL / 10) % 10 + 0x30);	// Преобразуем число в код числа
				sendcharlcd((uint16_t)(KUL / 1) % 10 + 0x30);	// Преобразуем число в код числа
			}

			if (Sum > 20) // если число импульсов с заданным критерием значения амплитуды (в единицах 8-разрядного кода АЦП) достигло количества более 70-ти
			{
				Mas_basedPD[k] = (uint8_t)(KUL); // запись значения установки потенциометра при работе с выбранным каналом
				_delay_ms(1000);				 // задержка 1 с
				break;							 // выход из текущего цикла
			}
		}

		if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
		{
			interrupt_button_ON; // разрешение прерываний по нажатию кнопок
		}
	}
	//---------------------------------------------------------------------------------------------------------------------------- Калибровка усиления сигнала (конец)

	if (Status_error_anemometr == 0) // если статус ошибки анемометра равен 0
	{
		eeprom_write_byte((uint8_t *)10, Mas_basedPD[0]); // запись в eeprom по адресу 10 коэффициента усиления 1-го канала 0-го уровня
		eeprom_write_byte((uint8_t *)11, Mas_basedPD[1]); // запись в eeprom по адресу 11 коэффициента усиления 2-го канала 0-го уровня
		eeprom_write_byte((uint8_t *)12, Mas_basedPD[2]); // запись в eeprom по адресу 12 коэффициента усиления 3-го канала 0-го уровня
		eeprom_write_byte((uint8_t *)13, Mas_basedPD[3]); // запись в eeprom по адресу 13 коэффициента усиления 4-го канала 0-го уровня
		eeprom_write_byte((uint8_t *)0, 1);				  // запись в eeprom по адресу 0 статуса калибровки усиления status_kal_KU=1
		func_eeprom_read();								  // вызов функции чтения из eeprom данных калибровки
	}

	if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
	{
		interrupt_button_ON; // разрешение прерываний по нажатию кнопок
	}
}
// —————————————

// —————————————
void func_DS18B20_detect(void) // функция обнаружения датчика DS18B20
{
	// uint8_t i=0; //объявление переменной для подсчёта интервала времени ожидания

	//_delay_ms(100); //задержка 1 мс
	DS18B20_out_0;	// конфигурирование линии PE3 порта E как выход и установка лог."0"
	_delay_us(600); // задержка 600 мкс
	DS18B20_input;	// конфигурирование линии PE3 порта E как вход
	_delay_us(70);	// задержка 70 мкс

	if (!DS18B20_read_0) // если на линии PE3 порта E присутствeт лог."1"
	{
		Status_error_DS18B20 = 1; // присвоение статусу ошибки связи с датчиком error_DS18B20 значения "1" (присутствует ошибка)
		return;					  // выход из функции
	}
	else // иначе
	{
		_delay_us(240);		// задержка 240 мкс
		if (DS18B20_read_0) // если на линии PE3 порта E присутствeт лог."0"
		{
			Status_error_DS18B20 = 1; // присвоение статусу ошибки связи с датчиком error_DS18B20 значения "1" (присутствует ошибка)
			return;					  // выход из функции
		}
	}
}
// —————————————

// —————————————
void func_DS18B20_out_bit(uint8_t bit) // функция передачи одного бита
{
	DS18B20_out_0; // конфигурирование линии PE3 порта E как выход и установка лог."0"

	if (bit == 1)
	{
		_delay_us(10); // задержка 10 мкс
		DS18B20_out_1; // конфигурирование линии PE3 порта E как выход и установка лог."1"
		_delay_us(90); // задержка 90 мкс
	}
	else
	{
		_delay_us(90); // задержка 90 мкс
		DS18B20_out_1; // конфигурирование линии PE3 порта E как выход и установка лог."1"
		_delay_us(10); // задержка 10 мкс
	}
}
// ————

// —————————————
void func_DS18B20_out_byte(uint8_t byte) // функция передачи одного байта
{
	// func_DS18B20_out_bit(1&byte); //вызов функции передачи одного бита
	for (uint8_t i = 0; i < 8; i++) // цикл от 0 до 7
	{
		func_DS18B20_out_bit(1 & (byte >> i)); // вызов функции передачи одного бита
	}
}
// —————————————

// —————————————
void func_DS18B20_read(uint8_t Nbyte) // функция чтения заданного количества Nbyte байт данных датчика DS18B20
{
	uint8_t Mas_bit[8]; // объявление массива битов Mas_bit для хранения байта

	func_DS18B20_out_byte(0xBE); // передача команды "чтение памяти"

	for (uint8_t i = 0; i < Nbyte; i++) // цикл от 0 до (Nbyte-1)
	{
		for (uint8_t j = 0; j < 8; j++) // цикл от 0 до 7
		{
			DS18B20_out_0;		// конфигурирование линии PE3 порта E как выход и установка лог."0"
			_delay_us(5);		// задержка 5 мкс
			DS18B20_input;		// конфигурирование линии PE3 порта E как вход
			_delay_us(20);		// задержка 20 мкс
			if (DS18B20_read_0) // если на линии PE3 порта E присутствeт лог."0"
			{
				Mas_bit[j] = 0; // присвоить значение 0 текущему значению массива Mas_bit
			}
			else // иначе
			{
				Mas_bit[j] = 1; // присвоить значение 1 текущему значению массива Mas_bit
			}
			_delay_us(25); // задержка 25 мкс
		}
		Mas_DS18B20[i] = Mas_bit[0] + (Mas_bit[1] << 1) + (Mas_bit[2] << 2) + (Mas_bit[3] << 3) + (Mas_bit[4] << 4) + (Mas_bit[5] << 5) + (Mas_bit[6] << 6) + (Mas_bit[7] << 7); // восстановление i-го переданного байта с сохранением в массив Mas_DS18B20
	}
}
// —————————————

// —————————————
void func_DS18B20_write(int8_t TH, int8_t TL, uint8_t Razr) // функция записи разрядности измеряемой температуры, верхнего и нижнего значения температуры аварии датчика DS18B20
{
	switch (Razr)
	{
	case 9:			 // если разрядность измеряемой температуры датчика DS18B20 задана равной 9
		Razr = 0x1F; // присвоение битам разрядности значений: R1=0 и R0=0
		break;

	case 10:		 // если разрядность измеряемой температуры датчика DS18B20 задана равной 10
		Razr = 0x3F; // присвоение битам разрядности значений: R1=0 и R0=1
		break;

	case 11:		 // если разрядность измеряемой температуры датчика DS18B20 задана равной 11
		Razr = 0x5F; // присвоение битам разрядности значений: R1=1 и R0=0
		break;

	case 12:		 // если разрядность измеряемой температуры датчика DS18B20 задана равной 12
		Razr = 0x7F; // присвоение битам разрядности значений: R1=1 и R1=1
		break;
	}
	func_DS18B20_out_byte(0x4E);		  // передача команды "запись"
	func_DS18B20_out_byte((uint8_t)(TH)); // передача байта записи верхнего значения температуры аварии датчика DS18B20TH
	func_DS18B20_out_byte((uint8_t)(TL)); // передача байта записи нижнего значения температуры аварии датчика DS18B20TH
	func_DS18B20_out_byte(Razr);		  // передача байта записи значения разрядности измеряемой температуры аварии датчика DS18B20TH
	func_DS18B20_detect();				  // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1)		  // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_out_byte(0x48); // передача команды "запись в EEPROM"
}
// —————————————

// —————————————
void func_DS18B20_ini(void) // функция инициализации датчика DS18B20
{
	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_out_byte(0xB8); // передача команды "Повторная загрузка"
	while (DS18B20_read_0)		 // пока на линии PE3 порта E присутствeт лог."0"
	{
		_delay_us(10); // задержка 10 мкс
	}

	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC);																		   // передача команды "пропуск ROM"
	func_DS18B20_read(5);																				   // вызов функции чтения 5-ти байт данных датчика DS18B20
	if ((Mas_DS18B20[4] != 0x7F) || ((int8_t)(Mas_DS18B20[3]) != -41) || ((int8_t)(Mas_DS18B20[2]) != 61)) // если текущая разрядность измеряемой температуры датчика DS18B20 не равна 12
	// или верхняя температура аварии не равна 61 градусу или нижняя температура аварии не равна минус 41 градусу
	{
		func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
		if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
		{
			return; // выход из функции
		}
		func_DS18B20_out_byte(0xCC);	 // передача команды "пропуск ROM"
		func_DS18B20_write(61, -41, 12); // вызов функции записи разрядности измеряемой температуры равной 12, верхнего и нижнего значения температуры аварии датчика DS18B20
	}
	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_read(5);		 // вызов функции чтения 5-ти байт данных датчика DS18B20
}
// —————————————

// —————————————
void func_DS18B20_temperature_meas_start(void) // функция старта измерения температуры датчика DS18B20
{
	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_out_byte(0xB8); // передача команды "Повторная загрузка"
	while (DS18B20_read_0)		 // пока на линии PE3 порта E присутствeт лог."0"
	{
		_delay_us(10); // задержка 10 мкс
	}

	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		return; // выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_out_byte(0x44); // передача команды "запуск измерения температуры"
	//_delay_ms(800); //задержка 800 мc (необходимая задержка датчика DS18B20 для получения актуального 12-разрядного значения температуры)
}
// —————————————

// —————————————
void func_DS18B20_temperature_meas_read(void) // функция чтения измеренной температуры датчика DS18B20
{
	int16_t T; // вспомогательная переменная для рассчёта старшего байта температуры датчика DS18B20

	func_DS18B20_detect();		   // вызов функции обнаружения датчика DS18B20
	if (Status_error_DS18B20 == 1) // если присутствует статус ошибки связи с датчиком DS18B20
	{
		Nagrevatel_OFF; // отключение нагревателя
		return;			// выход из функции
	}
	func_DS18B20_out_byte(0xCC); // передача команды "пропуск ROM"
	func_DS18B20_read(5);		 // вызов функции чтения 5-ти байт данных датчика DS18B20

	T = Mas_DS18B20[1];																		   // запись старшего байта температуры датчика DS18B20
	DS18B20_T_full = (int16_t)(round(((double)((int16_t)((T << 8) + Mas_DS18B20[0]))) / 1.6)); // восстановление значения температуры датчика DS18B20 (в десятых долях градуса Цельсия)

	TPH_temp = (double)(DS18B20_T_full);												  // промежуточное сохранение данных температуры
	TPH_temp = Tst_low + (Tst_high - Tst_low) * (TPH_temp - Th_low) / (Th_high - Th_low); // промежуточное сохранение данных температуры
	DS18B20_T_full = (int16_t)(round(TPH_temp));										  // коррекция температуры датчика нагревателя по данным калибровки
}
// —————————————

// —————————————
void func_kalibrovka_veter(uint8_t Vektor, double V_ref) // функция калибровки с ветром (параметр Vektor=1 задаёт ось X; Vektor=2 задаёт ось Y; V_ref-скорость ветра (дм/c))
{
	uint16_t Data_eeprom; // объявление локальной переменной для записи в eeprom

	// func_skorost(0); //вызов функции скорости ветра
	func_skorost_N(10);				// вызов функции вычисления скорости ветра (в дм/с) 10 раз с усреднением
	if (Status_error_anemometr > 0) // если значение статуса ошибки анемометра не равно "0"
	{
		// func_vyvod_status_error(); //вызов функции вывода ошибки приёма данных
		Status_error_anemometr = 0; // обнуление переменной статуса ошибки анемометра
	}
	else // иначе
	{
		switch (Vektor)
		{
		case 1:																					// если Vektor=1 (задана калибровка ветра по оси X)
			Sx_kal = round(-Ct * Ct / 20000 * (double)(dT_k0_k1) / 6.4 / V_ref / Cos_a);		// вычисление расстояния Sx_kal (в десятых долях мм)
			Data_eeprom = (uint16_t)Sx_kal;														// приведение Sx_kal к целому типу данных
			eeprom_write_word((uint16_t *)40, Data_eeprom);										// запись в eeprom по адресу 40 значения Sx_kal
			Tx_kal = round(10000 * Sx_kal / (Ct + V_ref * Cos_a) - (double)(dT_k0_sred) / 6.4); // вычисление задержки Tx_kal (в десятых долях мкс)
			Data_eeprom = (uint16_t)Tx_kal;														// приведение задержки Tx_kal к целому типу данных
			eeprom_write_word((uint16_t *)42, Data_eeprom);										// запись в eeprom по адресу 42 значения Tx_kal
			eeprom_write_byte((uint8_t *)1, 1);													// запись в eeprom по адресу 1 значения status_kal_X=1 статуса калибровки с ветром по оси X
			break;

		case 2:																					// если Vektor=2 (задана калибровка ветра по оси Y)
			Sy_kal = round(Ct * Ct / 20000 * (double)(dT_k2_k3) / 6.4 / V_ref / Cos_a);			// вычисление расстояния Sy_kal (в десятых долях мм)
			Data_eeprom = (uint16_t)Sy_kal;														// приведение Sy_kal к целому типу данных
			eeprom_write_word((uint16_t *)50, Data_eeprom);										// запись в eeprom по адресу 50 значения Sy_kal
			Ty_kal = round(10000 * Sy_kal / (Ct - V_ref * Cos_a) - (double)(dT_k2_sred) / 6.4); // вычисление задержки Ty_kal (в десятых долях мкс)
			Data_eeprom = (uint16_t)Ty_kal;														// приведение задержки Ty_kal к целому типу данных
			eeprom_write_word((uint16_t *)52, Data_eeprom);										// запись в eeprom по адресу 52 значения Ty_kal
			eeprom_write_byte((uint8_t *)2, 1);													// запись в eeprom по адресу 2 значения status_kal_Y=1 статуса калибровки с ветром по оси Y
			break;
		}
		func_eeprom_read(); // вызов функции чтения из eeprom данных калибровки
	}
}
// —————————————

// —————————————
void func_kalibrovka_reset_K0(void) // функция сброса калибровки без ветра
{
	eeprom_write_byte((uint8_t *)0, 0); // сброс в eeprom по адресу 0 статуса калибровки status_kal_K0
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————

// —————————————
void func_kalibrovka_reset_XY(void) // функция сброса калибровки с ветром
{
	eeprom_write_byte((uint8_t *)1, 0); // сброс в eeprom по адресу 1 статуса калибровки status_kal_X
	eeprom_write_byte((uint8_t *)2, 0); // сброс в eeprom по адресу 2 статуса калибровки status_kal_Y
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————

// —————————————
void func_kalibrovka_reset_T(void) // функция сброса калибровки температуры и температуры подогрева
{
	eeprom_write_byte((uint8_t *)3, 0); // сброс в eeprom по адресу 3 статуса калибровки температуры и температуры подогрева
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————

// —————————————
void func_reset_Th_on(void) // функция сброса температуры включения подогрева
{
	eeprom_write_byte((uint8_t *)4, 0); // сброс в eeprom по адресу 4 статуса температуры включения подогрева
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————

// —————————————
void func_kalibrovka_reset_H(void) // функция сброса калибровки влажности
{
	eeprom_write_byte((uint8_t *)5, 0); // сброс в eeprom по адресу 5 статуса калибровки влажности
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————

// —————————————
void func_kalibrovka_reset_P(void) // функция сброса калибровки давления
{
	eeprom_write_byte((uint8_t *)6, 0); // сброс в eeprom по адресу 6 статуса калибровки давления
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки
}
// —————————————
//---------------------------------------------------------------------------------------------------------------------------- Функции калибровки (конец)

// —————————————
void twi_master_BME280_ini(void) // функция мастер-передатчик модуля twi для инициализации BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xF5; // запись в регистр данных адреса регистра конфигурации
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0xA0; // запись в регистр данных регистра конфигурации (длительность неактивности в нормальном режиме - 1000 мс, БИХ-фильтр выключен, SPI выключен)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0xF2; // запись в регистр данных адреса регистра контроля влажности
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0x01; // запись в регистр данных регистра контроля влажности (передискретизация влажности х1)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0xF4; // запись в регистр данных адреса регистра контроля измерений
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0x25; // запись в регистр данных регистра контроля измерений (передискретизация давления х1, передискретизация температуры х1, принудительный режим)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_master_BME280_start_meas(void) // функция старта измерения BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xF4; // запись в регистр данных адреса регистра контроля измерений
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	TWIE_MASTER_DATA = 0x25; // запись в регистр данных регистра контроля измерений (передискретизация давления х1, передискретизация температуры х1, принудительный режим)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_BME280_read1_kalibr(void) // 1-я функция мастер-приёмник модуля twi для чтения данных калибровки BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)

	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0x88; // запись в регистр данных адреса начального регистра для чтения
							 // while(!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) //ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 1; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом чтения данных (формирование пакета SLA+R)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
		; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")

	for (uint8_t i = 0; i < 23; i++) // цикл от 0 до 22
	{
		Mas_BME280_KALIBR[i] = TWIE_MASTER_DATA; // считывание принятого байта из регистра данных в ячейку массива данных Mas_meteo[0]
		twi_master_bit_ACK;						 // приём байта данных ведущим модулем twi с битом подтверждения
		while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
			; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")
		// while(!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm)); //ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")
	}

	Mas_BME280_KALIBR[23] = TWIE_MASTER_DATA; // считывание 24-го принятого байта из регистра данных в массив данных калибровки датчика BME280
	twi_master_bit_NACK;					  // приём байта данных ведущим модулем twi без бита подтверждения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm))
		; // ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_BME280_read2_kalibr(void) // 2-я функция мастер-приёмник модуля twi для чтения данных калибровки BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xA1; // запись в регистр данных адреса начального регистра для чтения
							 // while(!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) //ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 1; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом чтения данных (формирование пакета SLA+R)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
		; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")

	Mas_BME280_KALIBR[24] = TWIE_MASTER_DATA; // считывание 25-го принятого байта из регистра данных в массив данных калибровки датчика BME280
	twi_master_bit_NACK;					  // приём байта данных ведущим модулем twi без бита подтверждения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm))
		; // ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_BME280_read3_kalibr(void) // 3-я функция мастер-приёмник модуля twi для чтения данных калибровки BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xE1; // запись в регистр данных адреса начального регистра для чтения
							 // while(!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) //ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 1; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом чтения данных (формирование пакета SLA+R)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
		; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")

	for (uint8_t i = 25; i < 31; i++) // цикл от 25 до 30
	{
		Mas_BME280_KALIBR[i] = TWIE_MASTER_DATA; // считывание принятого байта из регистра данных в ячейку массива данных Mas_meteo[0]
		twi_master_bit_ACK;						 // приём байта данных ведущим модулем twi с битом подтверждения
		while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
			; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")
		// while(!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm)); //ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")
	}

	Mas_BME280_KALIBR[31] = TWIE_MASTER_DATA; // считывание 32-го принятого байта из регистра данных в массив данных калибровки датчика BME280
	twi_master_bit_NACK;					  // приём байта данных ведущим модулем twi без бита подтверждения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm))
		; // ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_BME280_read_TPH(void) // функция мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	// while((TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm)); //ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(100); // задержка 1мкс
		i++;			// инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xF7; // запись в регистр данных адреса начального регистра для чтения
							 // while(!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) //ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 1; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом чтения данных (формирование пакета SLA+R)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
		; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")

	for (uint8_t i = 0; i < 7; i++) // цикл от 0 до 7
	{
		Mas_BME280_TPH[i] = TWIE_MASTER_DATA; // считывание i-го принятого байта из регистра данных в массив данных температуры, влажности и давления датчика BME280
		twi_master_bit_ACK;					  // приём байта данных ведущим модулем twi с битом подтверждения
		while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
			; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")
		// while(!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm)); //ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")
	}

	Mas_BME280_TPH[7] = TWIE_MASTER_DATA; // считывание 8-го принятого байта из регистра данных в массив данных температуры, влажности и давления датчика BME280
	twi_master_bit_NACK;				  // приём байта данных ведущим модулем twi без бита подтверждения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm))
		; // ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void twi_BME280_read_ID(void) // функция мастер-приёмник модуля twi для чтения данных ID BME280
{
	uint8_t i = 0; // объявление переменной для подсчёта интервала времени ожидания

	twi_master_IDLE;  // формирование состояния "IDLE" (шина свободна) модулем twi
	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 0; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом записи данных (формирование пакета SLA+W)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm)) // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")
	{
		if (i == 50) // если интервал времени ожидания превысил 50 мкс
		{
			twi_master_STOP;		 // формирование состояния "СТОП" модулем twi
			Status_error_BME280 = 1; // присвоение статусу ошибки связи с модулем BME280 значения "1" (присутствует ошибка)
			return;
		}
		_delay_us(1); // задержка 1мкс
		i++;		  // инкремент переменной времени ожидания
	}

	TWIE_MASTER_DATA = 0xD0; // запись в регистр данных адреса начального регистра для чтения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_WIF_bm))
		; // ожидание готовности флага передачи байта ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_START; // формирование состояния "СТАРТ" (или "ПОВСТАРТ") модулем twi

	TWIE_MASTER_ADDR = (twi_address_BME280 << 1) | 1; // запись twi-адреса датчика BME280 в регистр данных с управляющим битом чтения данных (формирование пакета SLA+R)
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_RIF_bm))
		; // ожидание готовности флага чтения байта ведущего модуля twi (цикл, пока бит равен лог."0")

	Mas_meteo[0] = TWIE_MASTER_DATA; // считывание принятого байта из регистра данных в ячейку массива данных Mas_meteo[0]
	twi_master_bit_NACK;			 // приём байта данных ведущим модулем twi без бита подтверждения
	while (!(TWIE_MASTER_STATUS & TWI_MASTER_CLKHOLD_bm))
		; // ожидание готовности флага синхронизации ведущего модуля twi (цикл, пока бит равен лог."0")

	twi_master_STOP; // формирование состояния "СТОП" модулем twi
}
// —————————————

// —————————————
void repacking_BME280_kalibr(void) // функция распаковки данных калибровки c датчика BME280
{
	DIG_T1 = Mas_BME280_KALIBR[0] + (Mas_BME280_KALIBR[1] << 8); // вычисление переменной для хранения данных калибровки температуры DIG_T1 датчика BME280
	DIG_T2 = Mas_BME280_KALIBR[2] + (Mas_BME280_KALIBR[3] << 8); // вычисление переменной для хранения данных калибровки температуры DIG_T2 датчика BME280
	DIG_T3 = Mas_BME280_KALIBR[4] + (Mas_BME280_KALIBR[5] << 8); // вычисление переменной для хранения данных калибровки температуры DIG_T3 датчика BME280

	DIG_P1 = Mas_BME280_KALIBR[6] + (Mas_BME280_KALIBR[7] << 8);   // вычисление переменной для хранения данных калибровки давления DIG_P1 датчика BME280
	DIG_P2 = Mas_BME280_KALIBR[8] + (Mas_BME280_KALIBR[9] << 8);   // вычисление переменной для хранения данных калибровки давления DIG_P2 датчика BME280
	DIG_P3 = Mas_BME280_KALIBR[10] + (Mas_BME280_KALIBR[11] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P3 датчика BME280
	DIG_P4 = Mas_BME280_KALIBR[12] + (Mas_BME280_KALIBR[13] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P4 датчика BME280
	DIG_P5 = Mas_BME280_KALIBR[14] + (Mas_BME280_KALIBR[15] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P5 датчика BME280
	DIG_P6 = Mas_BME280_KALIBR[16] + (Mas_BME280_KALIBR[17] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P6 датчика BME280
	DIG_P7 = Mas_BME280_KALIBR[18] + (Mas_BME280_KALIBR[19] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P7 датчика BME280
	DIG_P8 = Mas_BME280_KALIBR[20] + (Mas_BME280_KALIBR[21] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P8 датчика BME280
	DIG_P9 = Mas_BME280_KALIBR[22] + (Mas_BME280_KALIBR[23] << 8); // вычисление переменной для хранения данных калибровки давления DIG_P9 датчика BME280

	DIG_H1 = Mas_BME280_KALIBR[24];													  // вычисление переменной для хранения данных калибровки влажности DIG_H1 датчика BME280
	DIG_H2 = Mas_BME280_KALIBR[25] + (Mas_BME280_KALIBR[26] << 8);					  // вычисление переменной для хранения данных калибровки влажности DIG_H2 датчика BME280
	DIG_H3 = Mas_BME280_KALIBR[27];													  // вычисление переменной для хранения данных калибровки влажности DIG_H3 датчика BME280
	DIG_H4 = (Mas_BME280_KALIBR[28] << 4) + ((Mas_BME280_KALIBR[29]) & (0b00001111)); // вычисление переменной для хранения данных калибровки влажности DIG_H4 датчика BME280
	DIG_H5 = (Mas_BME280_KALIBR[29] >> 4) + (Mas_BME280_KALIBR[30] << 4);			  // вычисление переменной для хранения данных калибровки влажности DIG_H5 датчика BME280
	DIG_H6 = Mas_BME280_KALIBR[31];													  // вычисление переменной для хранения данных калибровки влажности DIG_H6 датчика BME280
}
// —————————————

// —————————————
void func_compensate_TPH(void) // функция вычисления компенсированных значений температуры, влажности и давления
{
	int32_t BME280_T;				  // переменная для хранения нескомпенсированной температуры
	int32_t BME280_compensate_T_temp; // объявление вспомогательной локальной переменной BME280_compensate_T_temp
	uint16_t BME280_compensate_T;	  // переменная для хранения скомпенсированной температуры
	uint64_t BME280_P;				  // переменная для хранения нескомпенсированного давления
	uint32_t BME280_compensate_P;	  // переменная для хранения скомпенсированного давления
	int32_t BME280_H;				  // переменная для хранения нескомпенсированной влажности
	uint16_t BME280_compensate_H;	  // переменная для хранения скомпенсированной влажности
	int32_t var1;					  // объявление вспомогательной локальной переменной var1
	int32_t var2;					  // объявление вспомогательной локальной переменной var2
	int32_t t_fine;					  // объявление вспомогательной локальной переменной t_fine
	int64_t var3;					  // объявление вспомогательной локальной переменной var3
	int64_t var4;					  // объявление вспомогательной локальной переменной var4
	int64_t pressure;				  // объявление вспомогательной локальной переменной pressure
	int64_t v_x1;					  // объявление вспомогательной локальной переменной v_x1

	//------------------------------------------------------------------------------------------------------------------------------------------------------ начало вычисления температуры
	BME280_T = ((uint32_t)(Mas_BME280_TPH[3]) << 16) + ((uint32_t)(Mas_BME280_TPH[4]) << 8) + (uint32_t)(Mas_BME280_TPH[5]); // побайтовое восстановление 24-х разрядного значения нескомпенсированной температуры
	BME280_T >>= 4;																											 // приведение нескомпенсированной температуры к 20-ти разрядному значению
	var1 = ((((BME280_T >> 3) - ((int32_t)DIG_T1 << 1))) * ((int32_t)DIG_T2)) >> 11;
	var2 = (((((BME280_T >> 4) - ((int32_t)DIG_T1)) * ((BME280_T >> 4) - ((int32_t)DIG_T1))) >> 12) * ((int32_t)DIG_T3)) >> 14;
	t_fine = var1 + var2;

	BME280_compensate_T_temp = (t_fine * 5 + 128) >> 8; // получение результата компенсированной температуры с разрешением 0,01°C (значение "5123" равно 51,23 °C)

	BME280_T_full = (int16_t)(round(((double)(BME280_compensate_T_temp)) / 10));								 // вычисление значения температуры модуля BME280 как числа со знаком (в десятых долях градуса Цельсия)
	TPH_temp = (double)(BME280_T_full);																			 // промежуточное сохранение данных температуры
	BME280_T_full = (int16_t)(round(Tst_low + (Tst_high - Tst_low) * (TPH_temp - Tm_low) / (Tm_high - Tm_low))); // коррекция температуры модуля BME280 по данным калибровки

	if (BME280_compensate_T_temp < 0) // если температура меньше 0
	{
		BME280_compensate_T_znak = 1; // переменной присваиваем значение "1"
	}
	else
	{
		BME280_compensate_T_znak = 0; // переменной присваиваем значение "0"
	}

	BME280_compensate_T = (uint16_t)(abs(BME280_compensate_T_temp));	// получение результата скомпенсированной температуры в двоично-десятичном коде с разрешением 0,1°C (положительное число)
	BME280_compensate_T1 = (uint8_t)((BME280_compensate_T / 100) % 10); // вычисление 1-го байта скомпенсированной температуры (десятки градусов Цельсия)
	BME280_compensate_T2 = (uint8_t)((BME280_compensate_T / 10) % 10);	// вычисление 2-го байта скомпенсированной температуры (единицы градусов Цельсия)
	BME280_compensate_T3 = (uint8_t)((BME280_compensate_T / 1) % 10);	// вычисление 3-го байта скомпенсированной температуры (десятые доли градуса Цельсия)
	//------------------------------------------------------------------------------------------------------------------------------------------------------ конец вычисления температуры

	//------------------------------------------------------------------------------------------------------------------------------------------------------ начало вычисления давления
	BME280_P = ((uint64_t)(Mas_BME280_TPH[0]) << 16) + ((uint64_t)(Mas_BME280_TPH[1]) << 8) + (uint64_t)(Mas_BME280_TPH[2]); // побайтовое восстановление 24-х разрядного значения нескомпенсированного давления
	BME280_P >>= 4;																											 // приведение нескомпенсированного давления к 20-ти разрядному значению
	var3 = ((int64_t)t_fine) - 128000;
	var4 = var3 * var3 * (int64_t)DIG_P6;
	var4 = var4 + ((var3 * (int64_t)DIG_P5) << 17);
	var4 = var4 + (((int64_t)DIG_P4) << 35);
	var3 = ((var3 * var3 * (int64_t)DIG_P3) >> 8) + ((var3 * (int64_t)DIG_P2) << 12);
	var3 = (((((int64_t)1) << 47) + var3)) * ((int64_t)DIG_P1) >> 33;

	if (var3 == 0) // если переменная var3 равна 0
	{
		BME280_compensate_P = 0; // возвращает давление, равное 0 (избегание исключения, вызванного делением на ноль)
	}
	else
	{
		pressure = 1048576 - BME280_P;
		pressure = (((pressure << 31) - var4) * 3125) / var3;
		var3 = (((int64_t)DIG_P9) * (pressure >> 13) * (pressure >> 13)) >> 25;
		var4 = (((int64_t)DIG_P8) * pressure) >> 19;
		pressure = ((pressure + var3 + var4) >> 8) + (((int64_t)DIG_P7) << 4); // возвращает давление в Па как 32-битное целое число без знака в формате Q24.8 (24 целых бита и 8 дробных битов).Выходное значение "24674867" представляет 24674867/256 = 96386,2 Па = 963,862 гПа
		// BME280_compensate_P=(uint32_t)pressure;
		BME280_compensate_P = (uint32_t)(95 * pressure / 32424); // возвращает целую часть давления в сотых долях от мм. рт. ст.
	}

	BME280_P_full = (uint16_t)(round(((double)(BME280_compensate_P)) / 10));									  // вычисление значения давления модуля BME280 как числа без знака (в десятых долях мм. рт. ст.)
	TPH_temp = (double)(BME280_P_full);																			  // промежуточное сохранение данных давления
	BME280_P_full = (uint16_t)(round(Pst_low + (Pst_high - Pst_low) * (TPH_temp - Pm_low) / (Pm_high - Pm_low))); // коррекция давления модуля BME280 по данным калибровки

	BME280_compensate_P1 = (uint8_t)((BME280_compensate_P / 1000) % 10); // вычисление 1-го байта скомпенсированного давления (сотни мм рт. ст.)
	BME280_compensate_P2 = (uint8_t)((BME280_compensate_P / 100) % 10);	 // вычисление 2-го байта скомпенсированного давления (десятки мм рт. ст.)
	BME280_compensate_P3 = (uint8_t)((BME280_compensate_P / 10) % 10);	 // вычисление 3-го байта скомпенсированного давления (единицы мм рт. ст.)
	BME280_compensate_P4 = (uint8_t)((BME280_compensate_P / 1) % 10);	 // вычисление 4-го байта скомпенсированного давления (десятые доли мм рт. ст.)
	//------------------------------------------------------------------------------------------------------------------------------------------------------ конец вычисления давления

	//------------------------------------------------------------------------------------------------------------------------------------------------------ начало вычисления влажности
	BME280_H = ((uint32_t)(Mas_BME280_TPH[6]) << 8) + (uint32_t)Mas_BME280_TPH[7]; // побайтовое восстановление 16-ти разрядного значения нескомпенсированной влажности
	v_x1 = (t_fine - ((int32_t)76800));
	v_x1 = (((((BME280_H << 14) - (((int32_t)DIG_H4) << 20) - (((int32_t)DIG_H5) * v_x1)) + ((int32_t)16384)) >> 15) * (((((((v_x1 * ((int32_t)DIG_H6)) >> 10) * (((v_x1 * ((int32_t)DIG_H4)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) * ((int32_t)DIG_H2) + 8192) >> 14));
	v_x1 = (v_x1 - (((((v_x1 >> 15) * (v_x1 >> 15)) >> 7) * ((int32_t)DIG_H1)) >> 4));

	if (v_x1 < 0) // если значение переменной v_x1 меньше 0
	{
		v_x1 = 0; // переменной v_x1 присвоить значение 0
	}
	if (v_x1 > 419430400) // если значение переменной v_x1 больше 419430400
	{
		v_x1 = 419430400; // переменной v_x1 присвоить значение 419430400
	}
	// BME280_compensate_H = (uint32_t)(v_x1>>12); //возвращает влажность в % как 32-битное целое число без знака в формате Q22.10 (22 целых бита и 10 дробных битов). Выходное значение "47445" представляет 46,333% относительной влажности
	BME280_compensate_H = (uint16_t)((100 * v_x1) >> 22); // возвращает влажность в сотых долях %. Выходное значение "4756" представляет 47,56% относительной влажности

	BME280_H_full = (uint16_t)(round(((double)(BME280_compensate_H)) / 10));									  // вычисление значения влажности модуля BME280 как числа без знака (в десятых долях процентов)
	TPH_temp = (double)(BME280_H_full);																			  // промежуточное сохранение данных влажности
	BME280_H_full = (uint16_t)(round(Hst_low + (Hst_high - Hst_low) * (TPH_temp - Hm_low) / (Hm_high - Hm_low))); // коррекция влажности модуля BME280 по данным калибровки

	BME280_compensate_H1 = (uint8_t)((BME280_compensate_H / 100) % 10); // вычисление 1-го байта скомпенсированной влажности (десятки процентов относительной влажности)
	BME280_compensate_H2 = (uint8_t)((BME280_compensate_H / 10) % 10);	// вычисление 2-го байта скомпенсированной влажности (единицы процентов относительной влажности)
	BME280_compensate_H3 = (uint8_t)((BME280_compensate_H / 1) % 10);	// вычисление 3-го байта скомпенсированной влажности (десятые доли процента относительной влажности)
	//------------------------------------------------------------------------------------------------------------------------------------------------------ конец вычисления влажности
}
// —————————————

// —————————————
void func_packing_meteo(void) // функция упаковки метеоданных в массив
{
	if (Status_Nagrevatel_ON) // если нагреватель включён
	{
		Mas_meteo[0] = 1; // запись в массив метеоданных состояния "нагреватель включён"
	}
	else // иначе
	{
		Mas_meteo[0] = 0; // запись в массив метеоданных состояния "нагреватель выключен"
	}

	Mas_meteo[1] = (uint8_t)(DS18B20_T_full >> 8); // запись старшего байта температуры датчика нагревателя (в десятых долях градуса Цельсия, int16_t)
	Mas_meteo[2] = (uint8_t)(DS18B20_T_full);	   // запись младшего байта температуры датчика нагревателя (в десятых долях градуса Цельсия, int16_t)

	Mas_meteo[3] = (uint8_t)(BME280_T_full >> 8); // запись старшего байта температуры модуля BME280 (в десятых долях градуса Цельсия, int16_t)
	Mas_meteo[4] = (uint8_t)(BME280_T_full);	  // запись младшего байта температуры модуля BME280 (в десятых долях градуса Цельсия, int16_t)

	Mas_meteo[5] = (uint8_t)(BME280_P_full >> 8); // запись старшего байта давления модуля BME280 (в десятых долях мм рт. ст., uint16_t)
	Mas_meteo[6] = (uint8_t)(BME280_P_full);	  // запись младшего байта температуры модуля BME280 (в десятых долях мм рт. ст., uint16_t)

	Mas_meteo[7] = (uint8_t)(BME280_H_full >> 8); // запись старшего байта относительной влажности модуля BME280 (в десятых долях процентов, uint16_t)
	Mas_meteo[8] = (uint8_t)(BME280_H_full);	  // запись младшего байта относительной влажности модуля BME280 (в десятых долях процентов, uint16_t)

	Mas_meteo[9] = (uint8_t)((int16_t)(round(Vx)) >> 8); // запись старшего байта скорости ветра по оси X (в дм/с, int16_t)
	Mas_meteo[10] = (uint8_t)((int16_t)(round(Vx)));	 // запись младшего байта скорости ветра по оси X (в дм/с, int16_t)

	Mas_meteo[11] = (uint8_t)((int16_t)(round(Vy)) >> 8); // запись старшего байта скорости ветра по оси Y (в дм/с, int16_t)
	Mas_meteo[12] = (uint8_t)((int16_t)(round(Vy)));	  // запись младшего байта скорости ветра по оси Y (в дм/с, int16_t)

	Mas_meteo[13] = (uint8_t)((int16_t)(round(V)) >> 8); // запись старшего байта результирующей скорости ветра (в дм/с, uint16_t)
	Mas_meteo[14] = (uint8_t)((int16_t)(round(V)));		 // запись младшего байта результирующей скорости ветра (в дм/с, uint16_t)

	Mas_meteo[15] = (uint8_t)((int16_t)(round(Napr)) >> 8); // запись старшего байта направления ветра (в градусах, int16_t)
	Mas_meteo[16] = (uint8_t)((int16_t)(round(Napr)));		// запись младшего байта направления ветра (в градусах, int16_t)

	Mas_meteo[17] = (uint8_t)((int16_t)(round(Cx)) >> 8); // запись старшего байта скорости ультразвука по оси X (в дм/с, int16_t)
	Mas_meteo[18] = (uint8_t)((int16_t)(round(Cx)));	  // запись младшего байта скорости ультразвука по оси X (в дм/с, int16_t)

	Mas_meteo[19] = (uint8_t)((int16_t)(round(Cy)) >> 8); // запись старшего байта скорости ультразвука по оси Y (в дм/с, int16_t)
	Mas_meteo[20] = (uint8_t)((int16_t)(round(Cy)));	  // запись младшего байта скорости ультразвука по оси Y (в дм/с, int16_t)
}
// —————————————

// —————————————
void func_kalibrovka_null(void) // функция калибровки нуля
{
	uint16_t Data_eeprom; // объявление локальной переменной в eeprom

	if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
	{
		interrupt_button_OFF;		   // запрет прерываний по нажатию кнопок
		clearlcd();					   // очистка дисплея
		setpos(0, 0);				   // устанавливаем курсор в начальное положение 1-й строки
		str_lcd(" Ґгµї ё·јepeЅёe..."); // выводим надпись " Идёт измерение..."
	}

	/*
	func_DS18B20_temperature_meas_start(); //вызов функции старта измерения температуры датчика DS18B20
	_delay_ms(800); //задержка 800 мc (необходимая задержка датчика DS18B20 для получения актуального 12-разрядного значения температуры)
	func_DS18B20_temperature_meas_read(); //вызов чтения измеренной температуры датчика DS18B20
		if ((Status_error_DS18B20==1) || (DS18B20_T_full==850)) //если значение статуса ошибки связи с с датчиком DS18B20 значения "1" (присутствует ошибка)
		//или измеренное значение температуры датчика DS18B20 равно +85,0 градусов Цельсия (начальное значение температуры при запуске датчика DS18B20)
		{
			if (Marker_button==1) //если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
			{
			interrupt_button_ON; //разрешение прерываний по нажатию кнопок
			}
		return; //выход из функции
		}
	//Ct=3314.5*(sqrt(1+((double)(DS18B20_T_full)/2731.5))); //вычисление актуальной скорости ультразвука (в дм/c) в нормальных условиях при текущей температуре
	Ct=63.366*(sqrt(2731.5+(double)(DS18B20_T_full))); //вычисление актуальной скорости ультразвука (в дм/c) в нормальных условиях при текущей температуре
	*/

	Status_error_BME280 = 0;		// обнуление переменной статуса ошибки связи с модулем BME280
	twi_master_BME280_ini();		// вызов функции ведущего модуля twi для инициализации BME280
	_delay_ms(100);					// задержка 100 мс
	twi_BME280_read1_kalibr();		// вызов 1-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	twi_BME280_read2_kalibr();		// вызов 2-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	twi_BME280_read3_kalibr();		// вызов 3-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	repacking_BME280_kalibr();		// вызов функции распаковки данных калибровки c датчика BME280
	twi_master_BME280_start_meas(); // вызов функции старта измерения BME280
	_delay_ms(100);					// задержка 100 мс
	twi_BME280_read_TPH();			// вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
	func_compensate_TPH();			// вызов функции вычисления компенсированных значений температуры, давления и влажности

	if (Status_error_BME280 == 1) // если значение статуса ошибки связи с с датчиком BME значения "1" (присутствует ошибка)
	{
		if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
		{
			interrupt_button_ON; // разрешение прерываний по нажатию кнопок
		}
		return; // выход из функции
	}
	Ct = 63.366 * (sqrt(2731.5 + (double)(BME280_T_full))); // вычисление актуальной скорости ультразвука (в дм/c) в нормальных условиях при текущей температуре

	for (uint8_t i = 0; i < 10; i++) // цикл от 0 до 9
	{
		func_baze_sbor_dannyh(N_prohodov); // вызов функции базового сбора данных
		if (Status_error_anemometr > 0)	   // если значение статуса ошибки анемометра не равно "0"
		{
			if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
			{
				interrupt_button_ON; // разрешение прерываний по нажатию кнопок
			}
			return; // выход из функции
		}
		func_matstat_lux_X(32767); // вызов функции преобразования массива по оси X из N_prohodov элементов
		func_matstat_lux_Y(32767); // вызов функции преобразования массива по оси Y из N_prohodov элементов

		Mas_timer_integral_X[0][i] = dT_k0_sred; // запись среднего значения времени по оси X
		Mas_timer_integral_X[1][i] = dT_k0_k1;	 // запись среднего значения разницы времени по оси X
		Mas_timer_integral_Y[0][i] = dT_k2_sred; // запись среднего значения времени по оси Y
		Mas_timer_integral_Y[1][i] = dT_k2_k3;	 // запись среднего значения разницы времени по оси Y

		if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
		{
			clearlcd();								// очистка дисплея
			setpos(0, 0);							// устанавливаем курсор в начальное положение 1-й строки
			str_lcd(" Ґгµї ё·јepeЅёe...");			// выводим надпись " Идёт измерение..."
			setpos(0, 1);							// устанавливаем курсор в начальное положение 2-й строки
			str_lcd("  BГѕo»ЅeЅo: ");				// выводим надпись "  Выполнено: "
			sendcharlcd((uint16_t)(i) % 10 + 0x30); // Преобразуем число в код числа
			str_lcd("0 %   ");						// выводим надпись "0 %   "
		}
	}

	func_matstat_integral_sred(); // вызов функции вычисления среднего значения интегральных массивов

	dT_k0_k1_null = dT_k0_k1;								 // сохранение переменной для хранения разницы времени прохождения сигнала в канале 0 и канале 1 при калибровке без ветра (в тактах микроконтроллера)
	dT_k2_k3_null = dT_k2_k3;								 // сохранение переменной для хранения разницы времени прохождения сигнала в канале 2 и канале 3 при калибровке без ветра (в тактах микроконтроллера)
	dTx = dT_k0_sred;										 // сохранение переменной для задания дополнительной задержки (во время работы таймера) прихода пачки импульсов по оси X (в тактах микроконтроллера)
	dTy = dT_k2_sred;										 // сохранение переменной для задания дополнительной задержки (во время работы таймера) прихода пачки импульсов по оси Y (в тактах микроконтроллера)
	Tx = round(10000 / Ct * S - (double)(dT_k0_sred) / 6.4); // вычисление общей задержки прихода пачки импульсов по оси X (в десятых долях мкс)
	Ty = round(10000 / Ct * S - (double)(dT_k2_sred) / 6.4); // вычисление общей задержки прихода пачки импульсов по оси Y (в десятых долях мкс)

	eeprom_write_byte((uint8_t *)10, Mas_basedPD[0]); // запись в eeprom по адресу 10 коэффициента усиления 1-го канала 0-го уровня
	eeprom_write_byte((uint8_t *)11, Mas_basedPD[1]); // запись в eeprom по адресу 11 коэффициента усиления 2-го канала 0-го уровня
	eeprom_write_byte((uint8_t *)12, Mas_basedPD[2]); // запись в eeprom по адресу 12 коэффициента усиления 3-го канала 0-го уровня
	eeprom_write_byte((uint8_t *)13, Mas_basedPD[3]); // запись в eeprom по адресу 13 коэффициента усиления 4-го канала 0-го уровня

	eeprom_write_word((uint16_t *)20, dT_k0_k1_null); // запись в eeprom по адресу 20 значения dT_k0_k1_null
	eeprom_write_word((uint16_t *)22, dT_k2_k3_null); // запись в eeprom по адресу 22 значения dT_k2_k3_null
	eeprom_write_word((uint16_t *)24, dTx);			  // запись в eeprom по адресу 24 значения dTx
	eeprom_write_word((uint16_t *)26, dTy);			  // запись в eeprom по адресу 26 значения dTy

	Data_eeprom = (uint16_t)Tx;						// приведение задержки Tx к целому типу данных
	eeprom_write_word((uint16_t *)28, Data_eeprom); // запись в eeprom по адресу 28 значения Tx
	Data_eeprom = (uint16_t)Ty;						// приведение задержки Ty к целому типу данных
	eeprom_write_word((uint16_t *)30, Data_eeprom); // запись в eeprom по адресу 30 значения Ty
	Data_eeprom = (uint16_t)Ct;						// приведение задержки Ct к целому типу данных
	eeprom_write_word((uint16_t *)32, Data_eeprom); // запись в eeprom по адресу 32 значения Ct

	eeprom_write_byte((uint8_t *)0, 1); // запись в eeprom по адресу 0 статуса калибровки нуля status_kal_K0=1
	func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

	if (Marker_button == 1) // если метеоблок находится в сервисном режиме (необходим вывод данных на ЖКИ)
	{
		interrupt_button_ON; // разрешение прерываний по нажатию кнопок
	}
}
// —————————————

// —————————————
void func_USART_speed(uint8_t S) // функция задания значения кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с, "2" - 19,2 кбит/с, "3" - 38,4 кбит/с)
{
	USARTC1_CTRLA = USART_RXCINTLVL_OFF_gc;						  // запрет прерываний по завершению приёма
	USARTC1_CTRLB &= (0 << USART_TXEN_bp) | (0 << USART_RXEN_bp); // выключение приемника и передатчика
	USART_speed = S;											  // сохранение значения скорости передачи данных модуля USART

	switch (USART_speed)
	{
	case 1:								// запись значения кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с)
		USARTC1_BAUDCTRLB = 0b11011100; // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-3(в доп. коде) и BSEL[11:8]=0b1100
		USARTC1_BAUDCTRLA = 0b11111101; // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11111101 (BSEL[11:0]=0b110011111101=3325)
		break;

	case 2:								// запись значения кода скорости передачи данных модуля USART ("2" - 19,2 кбит/с)
		USARTC1_BAUDCTRLB = 0b11001100; // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-4(в доп. коде) и BSEL[11:8]=0b1100
		USARTC1_BAUDCTRLA = 0b11111101; // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11110101 (BSEL[11:0]=0b110011110101=3317)
		break;

	case 3:								// запись значения кода скорости передачи данных модуля USART ("3" - 38,4 кбит/с)
		USARTC1_BAUDCTRLB = 0b10111100; // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-5(в доп. коде) и BSEL[11:8]=0b1111
		USARTC1_BAUDCTRLA = 0b11100101; // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b00100000 (BSEL[11:0]=0b110011100101=3301)
		break;
	}

	USARTC1_CTRLA = USART_RXCINTLVL_LO_gc;		   // установка низкого уровня прерываний по завершению приёма
	USARTC1_CTRLB = USART_TXEN_bm | USART_RXEN_bm; // включение приемника и передатчика
}
// —————————————

// —————————————
void USART_ini() // функция инициализации модуля USART, cкорость 128000 БОД (для заданной тактовой частоты)
{
	PORTC_DIR |= 0b10100000; // конфигурируем линии порта C: PC5, PC7 - выходы
	PORTC_DIR &= 0b10111111; // конфигурируем линию PC6 порта C как вход
	PORTC_OUT &= 0b11011111; // установка лог."0" на выходе PC5 порта C (режим приёмника)
	// USARTC1_CTRLC = USART_CHSIZE_8BIT_gc | USART_SBMODE_bm; //задание групповой конфигурации 8 бит в посылке (по умолчанию без паритета, 1 стоповый бит)
	USARTC1_CTRLC = USART_CHSIZE_8BIT_gc; // задание групповой конфигурации 8 бит в посылке (по умолчанию без паритета, 1 стоповый бит)
	func_USART_speed(USART_speed);		  // функция задания значения кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с, "2" - 19,2 кбит/с, "3" - 38,4 кбит/с)
}
// —————————————

// —————————————
uint16_t func_calc_crc16(uint8_t *Mas_crc16, uint8_t size) // функция вычисления crc16 (первый аргумент-указатель на элемент массива Mas_crc16, второй - задаёт число элементов массива)
{
	uint16_t crc16 = 0xFFFF; // объявление переменной для хранения результата вычисления crc16 с заданием начального значения

	while (size--) // цикл, пока число элементов массива не равно 0
	{
		crc16 ^= *Mas_crc16++;
		for (uint8_t i = 0; i < 8; i++)
		{
			if (crc16 & 0x01) // если младший бит crc16 равен единице
			{
				crc16 = (crc16 >> 1) ^ 0xA001; // вычисление текущего значения crc16
			}
			else // иначе
			{
				crc16 = crc16 >> 1; // логический сдвиг вправо текущего значения crc16
			}
		}
	}
	return crc16; // возврат функцией значения crc16
}
// —————————————

/*
//—————————————
uint16_t func_calc_crc16_table(uint8_t *Mas_crc16, uint8_t size) //функция вычисления crc16 по таблице (первый аргумент-указатель на элемент массива Mas_crc16, второй - задаёт число элементов массива)
{

static const uint16_t Table_crc16[]= //вспомогательная таблица Table_crc16[] для быстрого вычисления crc16
{
0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};


uint16_t crc16=0xFFFF; //объявление переменной для хранения результата вычисления crc16 с заданием начального значения

	while (size--) //цикл, пока число элементов массива не равно 0
	{
	crc16 = (crc16 >> 8) ^ Table_crc16[(crc16 & 0xFF) ^ *Mas_crc16++]; //вычисление текущего значения crc16
	}
return crc16; //возврат функцией значения crc16
}
//—————————————
*/

// —————————————
void USART_mode_transceiver(uint8_t out) // функция управления приёмопередатчиком модуля USART с аргументом ("0" - режим приёмника, "1" - режим передатчика)
{
	if (out == 0)
	{
		PORTC_OUT &= 0b11011111; // включение режима приёмника модуля USART
	}
	else // иначе
	{
		PORTC_OUT |= 0b00100000; // включение режима передатчика модуля USART
	}
	_delay_ms(5); // задержка 5 мс
}
// —————————————

// —————————————
void USART_get_byte(void) // функция получения байта данных модуля USART
{
	uint8_t buffer; // объявление локальной переменной для храненея принятого байта данных

	while (!(USARTC1_STATUS & USART_RXCIF_bm))
		; // ожидание, когда в приёмном буфере появятся данные

	for (uint8_t i = 0; i < 75; i++) // цикл от 0 до 74
	{
		if (i == 74) // если в приёмном буфере нет данных в течении 750 мкс
		{
			Status_error_USART = 1; // запись статуса ошибки модуля USART
			return;					// выход из функции
		}
		if (!(USARTC1_STATUS & USART_RXCIF_bm)) // если в приёмном буфере нет данных
		{
			_delay_us(10); // задержка 10 мкс
		}
		else // иначе
		{
			break; // выход из цикла
		}
	}

	buffer = USARTC1_DATA;				// считывание данных из приёмного буфера
	counter_buffer++;					// инкремент переменной для хранения счётчика принятых/переданных байтов
	Mas_crc16[0] = counter_buffer;		// запись числа актуальных элементов массива
	Mas_crc16[counter_buffer] = buffer; // запись значения актуального элемента массива

	// if ((USARTC1_STATUS & (USART_FERR_bm | USART_PERR_bm | USART_BUFOVF_bm))==0) //если обнаружены ошибки при приёме байта данных
	//{
	// Status_error_USART=1; //запись статуса ошибки модуля USART
	// }
	// return buffer; //передача значения принятого байта данных
}
// —————————————

// —————————————
void USART_send_byte(uint8_t c) // функция передачи одного байта данных модуля USART
{
	while (!(USARTC1_STATUS & USART_DREIF_bm))
		;			  // ожидание, когда буфер передатчика станет пустым
	USARTC1_DATA = c; // запись символа в буфер передатчика USART_C1
	// while(!(USARTC1_STATUS & USART_TXCIF_bm)); //ожидание, когда передача байта завершена

	counter_buffer++;			   // инкремент переменной для хранения счётчика принятых/переданных байтов
	Mas_crc16[0] = counter_buffer; // запись числа актуальных элементов массива
	Mas_crc16[counter_buffer] = c; // запись значения актуального элемента массива

	switch (USART_speed)
	{
	case 1:				 // если значение скорости модуля USART равно 9,6 кбит/с
		_delay_us(1200); // задержка 1,2 мс на передачу байта
		break;

	case 2:				// если значение скорости модуля USART равно 19,2 кбит/с
		_delay_us(600); // задержка 600 мкс на передачу байта
		break;

	case 3:				// если значение скорости модуля USART равно 38,4 кбит/с
		_delay_us(300); // задержка 300 мкс на передачу байта
		break;
	}
}
// —————————————

// —————————————
void USART_sendString(uint8_t *text) // функция передачи строки символов модуля USART
{
	while (*text) // пока есть символы
	{
		USART_send_byte(*text++); // вызов функции передачи одного символа USART_C1
	}
}
// —————————————

// —————————————
void func_compare_crc16(void) // функция определения правильности принятого crc16
{
	uint16_t crc16_USART; // локальная переменная для хранения принятого значения crc16_USART
	uint16_t crc16_calc;  // локальная переменная для хранения расчётного значения crc16_calc

	USART_get_byte();																						// функция приёма старшего байта данных crc16 модуля USART
	USART_get_byte();																						// функция приёма младшего байта данных crc16 модуля USART
	crc16_USART = ((uint16_t)(Mas_crc16[counter_buffer - 1]) << 8) + (uint16_t)(Mas_crc16[counter_buffer]); // восстановление crc16_USART

	// crc16_USART=USART_get_byte(); //функция приёма старшего байта данных crc16 модуля USART
	// crc16_USART=(crc16_USART<<8)+USART_get_byte(); //функция приёма младшего байта данных модуля USART и восстановления crc16
	Mas_crc16[0] = Mas_crc16[0] - 2;						   // уменьшение числа элементов массива на 2
	crc16_calc = func_calc_crc16(&Mas_crc16[1], Mas_crc16[0]); // вызов функции вычисления crc16_calc (первый аргумент-указатель на элемент массива Mas_crc16, второй - задаёт число элементов массива)

	if (crc16_calc != crc16_USART) // если принятый crc16_USART не равен расчётному значению crc16_calc
	{
		Status_error_USART = 1; // запись статуса ошибки модуля USART
	}
	counter_buffer = 0; // обнуление переменной для хранения счётчика принятых/переданных байтов
}
// —————————————

// —————————————
void func_USART_send_crc16(void) // функция передачи crc16 модуля USART
{
	crc16 = func_calc_crc16(&Mas_crc16[1], Mas_crc16[0]); // вызов функции вычисления crc16 (первый аргумент-указатель на элемент массива Mas_crc16, второй - задаёт число элементов массива)
	USART_send_byte((uint8_t)(crc16 >> 8));				  // функция передачи старшего байта crc16 модуля USART
	USART_send_byte((uint8_t)(crc16));					  // функция передачи младшего байта crc16 модуля USART
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------- Прерывания (начало)
// —————————————
ISR(PORTE_INT0_vect) // программа обработки внешнего прерывания INT0 порта E (кнопка №1)
{
	// interrupt_OFF(); //вызов функции запрета прерываний
	_delay_ms(100);		 // задержка 100 мс
	if (nazata_knopka_1) // если кнопка №1 нажата более 100 мс
	{
		while (nazata_knopka_1) // ждём отпускания кнопки №1
		{
		}

		if (vyp_menu == 0) // если vyp_menu равно 0 (если не выполняется подпрограмма)
		{
			switch (tek_menu)
			{
			case 4100:			 // если tek_menu равно 4100
				tek_menu = 4000; // tek_menu присвоить значение 4000
				break;
			case 4200:			 // если tek_menu равно 4200
				tek_menu = 4000; // tek_menu присвоить значение 4000
				break;
			case 4300:			 // если tek_menu равно 4300
				tek_menu = 4000; // tek_menu присвоить значение 4000
				break;
			case 4400:			 // если tek_menu равно 4400
				tek_menu = 4000; // tek_menu присвоить значение 4000
				break;
			}
			func_otobr_menu(); // вызов функции отображения меню
		}
	}
	// interrupt_ON(); //вызов функции разрешения прерываний
}
// —————————————

// —————————————
ISR(PORTD_INT0_vect) // программа обработки внешнего прерывания INT0 порта D (кнопка №2)
{
	_delay_ms(100);		 // задержка 100 мс
	if (nazata_knopka_2) // если кнопка №2 нажата более 100 мс
	{
		while (nazata_knopka_2) // ждём отпускания кнопки №2
		{
		}

		if (vyp_menu != 0) // если vyp_menu не равно 0 (vyp_menu не равно 0 (если выполняется подпрограмма))
		{
			vyp_menu = 0; // vyp_menu присвоить значение 0 (отменить дальнейшее выполнение текущей подпрограммы)
		}
		else // если vyp_menu равно 0 (если не выполнялась подпрограмма)
		{
			switch (tek_menu)
			{
			case 1000:			 // если tek_menu равно 1000
				vyp_menu = 1000; // vyp_menu присвоить значение 1000
				break;
			case 2000:			 // если tek_menu равно 2000
				vyp_menu = 2000; // vyp_menu присвоить значение 2000
				break;
			case 3000:			 // если tek_menu равно 3000
				vyp_menu = 3000; // vyp_menu присвоить значение 3000
				break;
			case 4000:			 // если tek_menu равно 4000
				tek_menu = 4100; // tek_menu присвоить значение 4100
				break;
			case 4100:			 // если tek_menu равно 4100
				vyp_menu = 4100; // vyp_menu присвоить значение 4100
				break;
			case 4200:			 // если tek_menu равно 4200
				vyp_menu = 4200; // vyp_menu присвоить значение 4200
				break;
			case 4300:			 // если tek_menu равно 4300
				vyp_menu = 4300; // vyp_menu присвоить значение 4300
				break;
			case 4400:			 // если tek_menu равно 4400
				vyp_menu = 4400; // vyp_menu присвоить значение 4400
				break;
			}
		}
		func_otobr_menu(); // вызов функции отображения меню
	}
}
// —————————————

// —————————————
ISR(PORTD_INT1_vect) // программа обработки внешнего прерывания INT1 порта D (кнопка №3)
{
	_delay_ms(100);		 // задержка 100 мс
	if (nazata_knopka_3) // если кнопка №3 нажата более 100 мс
	{
		while (nazata_knopka_3) // ждём отпускания кнопки №3
		{
		}

		if (vyp_menu == 0) // если vyp_menu равно 0 (если не выполняется подпрограмма)
		{
			switch (tek_menu)
			{
			case 1000:					// если tek_menu равно 1000
				if (Marker_button == 0) // если с момента включения анемометра не была нажата кнопка №3 (с панели подключаемого LCD-модуля)
				{
					Marker_button = 1;			 // присвоение значение "1"
					clearlcd();					 // очистка дисплея
					setpos(0, 0);				 // устанавливаем курсор в начальное положение первой строки
					str_lcd("Bxoг і cepіёcЅГ№"); // выводим надпись "Вход в сервисный"
					setpos(0, 1);				 // устанавливаем курсор в начальное положение второй строки
					str_lcd("pe¶ёј paІoїГ... "); // выводим надпись "режим работы... "
					_delay_ms(2000);			 // задержка 2 с
				}
				else // иначе
				{
					tek_menu = 2000; // tek_menu присвоить значение 2000
				}
				break;
			case 2000:			 // если tek_menu равно 2000
				tek_menu = 3000; // tek_menu присвоить значение 3000
				break;
			case 3000:			 // если tek_menu равно 3000
				tek_menu = 4000; // tek_menu присвоить значение 4000
				break;
			case 4000:			 // если tek_menu равно 4000
				tek_menu = 1000; // tek_menu присвоить значение 1000
				break;
			case 4100:			 // если tek_menu равно 4100
				tek_menu = 4200; // tek_menu присвоить значение 4200
				break;
			case 4200:			 // если tek_menu равно 4200
				tek_menu = 4300; // tek_menu присвоить значение 4300
				break;
			case 4300:			 // если tek_menu равно 4300
				tek_menu = 4400; // tek_menu присвоить значение 4400
				break;
			case 4400:			 // если tek_menu равно 4400
				tek_menu = 4100; // tek_menu присвоить значение 4100
				break;
			}
			func_otobr_menu(); // вызов функции отображения меню
		}
	}
}
// —————————————

// —————————————
ISR(PORTA_INT0_vect) // программа обработки внешнего прерывания INT0 порта A (счёт и запись импульсов)
{
	Comparator_OFF; // запрет работы компаратора

	switch (temp % 4) // если остаток от деления текущего номера импульса на 4:
	{
	case 0:													  // равен 0
		Mas_amplitude_temp[nomer_kanala][temp] = ADCA_CH0RES; // запись предыдущего 8-разрядного значения результата преобразования 0-го канала АЦП в массив Mas_amplitude_temp
		_delay_us(0.15);									  // задержка 0,15 мкс
		ADCA_CTRLA |= (1 << ADC_CH0START_bp);				  // запуск нового преобразования в 0-м канале АЦП
		Mas_timer_temp[nomer_kanala][temp + 4] = TCC0_CNT;	  // запись со смещением текущего значения 16-битного таймера в массив Mas_timer_temp
		break;

	case 1:													  // равен 1
		Mas_amplitude_temp[nomer_kanala][temp] = ADCA_CH1RES; // запись предыдущего 8-разрядного значения результата преобразования 1-го канала АЦП в массив Mas_amplitude_temp
		_delay_us(0.15);									  // задержка 0,15 мкс
		ADCA_CTRLA |= (1 << ADC_CH1START_bp);				  // запуск нового преобразования в 1-м канале АЦП
		Mas_timer_temp[nomer_kanala][temp + 4] = TCC0_CNT;	  // запись со смещением текущего значения 16-битного таймера в массив Mas_timer_temp
		break;

	case 2:													  // равен 2
		Mas_amplitude_temp[nomer_kanala][temp] = ADCA_CH2RES; // запись предыдущего 8-разрядного значения результата преобразования 2-го канала АЦП в массив Mas_amplitude_temp
		_delay_us(0.15);									  // задержка 0,15 мкс
		ADCA_CTRLA |= (1 << ADC_CH2START_bp);				  // запуск нового преобразования в 2-м канале АЦП
		Mas_timer_temp[nomer_kanala][temp + 4] = TCC0_CNT;	  // запись со смещением текущего значения 16-битного таймера в массив Mas_timer_temp
		break;

	case 3:													  // равен 3
		Mas_amplitude_temp[nomer_kanala][temp] = ADCA_CH3RES; // запись предыдущего 8-разрядного значения результата преобразования 3-го канала АЦП в массив Mas_amplitude_temp
		_delay_us(0.15);									  // задержка 0,15 мкс
		ADCA_CTRLA |= (1 << ADC_CH3START_bp);				  // запуск нового преобразования в 3-м канале АЦП
		Mas_timer_temp[nomer_kanala][temp + 4] = TCC0_CNT;	  // запись со смещением текущего значения 16-битного таймера в массив Mas_timer_temp
		break;
	}

	if (temp == 99) // если число принятых импульсов стало равно 100
	{
		Timer_OFF; // выключение таймера счётчика
		// Mas_N_fix[nomer_kanala]=temp-1; //сохранение фиксированного номера точки текущего канала
		temp = 0; // обнуление переменной temp для хранения индекса текущего элемента массива
	}
	else
	{
		temp++;		   // инкремент переменной temp для хранения индекса текущего элемента массива
		Comparator_ON; // разрешение работы компаратора
	}
}
// —————————————

// —————————————
ISR(TCC0_OVF_vect) // программа обработки прерывания по переполнению таймера-счётчика
{
	Comparator_OFF; // запрет работы компаратора
	// Potentiometr_set(0);
	Timer_OFF; // выключение таймера счётчика
	/*
	if (temp<20) //если текущее значение переменной temp меньше 20
	{
	Status_error_anemometr=nomer_kanala+11; //сохранение статуса ошибки анемометра
	}
	*/
	temp = 0; // обнуление переменной temp для хранения индекса текущего элемента массива
}
// —————————————

/*
//—————————————
ISR(TCC1_OVF_vect) //программа обработки прерывания по переполнению таймера-счётчика управления подогревом
{
//interrupt_OFF; //глобальный запрет прерываний
func_DS18B20_temperature_meas_read(); //вызов функции чтения измеренной температуры датчика DS18B20

	if ((DS18B20_T_full<Th_on) && (Status_error_DS18B20!=1)) //если текущая температура нагревателя меньше значения нижнего порога температуры и отсутствует ошибка связи с датчиком DS18B20
	{
	Nagrevatel_ON; //включение нагревателя
	}
	else
	{
	Nagrevatel_OFF; //отключение нагревателя
	}

func_DS18B20_temperature_meas_start(); //вызов функции старта измерения температуры датчика DS18B20
//_delay_ms(800); //задержка 800 мc (необходимая задержка датчика DS18B20 для получения актуального 12-разрядного значения температуры)
//interrupt_ON; //глобальное разрешение прерываний
}
//—————————————
*/

// —————————————
ISR(RTC_COMP_vect) // программа обработки прерывания по переполнению таймера-счётчика управления подогревом
{
	interrupt_OFF; // глобальный запрет прерываний
	RTC_CNT = 0;   // сброс RTC

	func_DS18B20_temperature_meas_read();						 // вызов функции чтения измеренной температуры датчика DS18B20
	if ((DS18B20_T_full < Th_on) && (Status_error_DS18B20 != 1)) // если текущая температура нагревателя меньше значения нижнего порога температуры и отсутствует ошибка связи с датчиком DS18B20
	{
		Nagrevatel_ON; // включение нагревателя
	}
	else
	{
		Nagrevatel_OFF; // отключение нагревателя
	}
	func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20

	interrupt_ON; // глобальное разрешение прерываний
	return;		  // выходим из текущего прерывания
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------начало обработки прерывания модуля USART по завершению приёма данных
// —————————————
ISR(USARTC1_RXC_vect) // вектор обработки прерывания модуля USART_C1 по завершению приёма данных
{
	int16_t temp_C; // локальная переменная
	// Timer_heating_control_OFF; //выключение таймера-счётчика управления подогревом
	RTC_OFF;			// запрет прерывания счетчика реального времени RTC по совпадению
	RTC_CNT = 0;		// обнуление RTC
	counter_buffer = 0; // обнуление переменной для хранения счётчика принятых/переданных байтов

	// interrupt_OFF; //глобальный запрет прерываний
	// interrupt_OFF(); //вызов функции запрета прерываний
	USARTC1_CTRLA = 0; // запрет прерываний модуля USART
	USART_get_byte();  // считывание из приёмного буфера модуля USART байта адреса

	if (Mas_crc16[counter_buffer] == USART_address) // если принятый байт совпадает с адресом метеоблока М1
	{
		/*
		USART_mode_transceiver(1); //функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
		USART_send_byte(0x25); //вызов функции передачи байта адреса метеоблока М1 модуля USART
		USART_mode_transceiver(0); //функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
		USARTC1_CTRLA = USART_RXCINTLVL_LO_gc; //установка низкого уровня прерываний по завершению приёма
		return;
		*/

		USART_get_byte(); // считывание из приёмного буфера модуля USART байта кода функции

		switch (Mas_crc16[counter_buffer]) // начало перечисления байтов функций
		{
		case 0x41:			  // если байт кода функции соответствует команде присутствия-----------------------------------------------------------------начало функции 0x41
			USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных

			switch (Mas_crc16[counter_buffer])
			{
			case 0x00:							// если байт данных равен 0x00
				func_compare_crc16();			// вызов функции определения правильности принятого crc16
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					USART_send_byte(0x41); // вызов функции передачи байта кода функции модуля USART
				}
				else // иначе
				{
					USART_send_byte(0x41 + 0x80); // вызов функции передачи модифицированного байта кода функции модуля USART
				}
				USART_send_byte(USART_speed);								  // вызов функции передачи текущего байта кода скорости передачи данных модуля USART
				USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				Status_error_USART = 0;										  // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0);									  // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;

			case 0x01:							// если байт данных равен 0x01
				func_compare_crc16();			// вызов функции определения правильности принятого crc16
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
					USART_send_byte(1);											  // вызов функции передачи байта "1" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
					USART_speed = 1;											  // значение кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с)
					USARTC1_BAUDCTRLB = 0b11011100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-3(в доп. коде) и BSEL[11:8]=0b1100
					USARTC1_BAUDCTRLA = 0b11111101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11111101 (BSEL[11:0]=0b110011111101=3325) ("1" - 9,6 кбит/с)
				}
				else // иначе
				{
					USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
					USART_send_byte(1);											  // вызов функции передачи байта "1" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				}
				Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;

			case 0x02:							// если байт данных равен 0x02
				func_compare_crc16();			// вызов функции определения правильности принятого crc16
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
					USART_send_byte(2);											  // вызов функции передачи байта "2" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
					USART_speed = 2;											  // значение кода скорости передачи данных модуля USART ("2" - 19,2 кбит/с)
					USARTC1_BAUDCTRLB = 0b11001100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-4(в доп. коде) и BSEL[11:8]=0b1100
					USARTC1_BAUDCTRLA = 0b11111101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11110101 (BSEL[11:0]=0b110011110101=3317) ("2" - 19,2 кбит/с)
				}
				else // иначе
				{
					USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
					USART_send_byte(2);											  // вызов функции передачи байта "2" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				}
				Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;

			case 0x03:							// если байт данных равен 0x03
				func_compare_crc16();			// вызов функции определения правильности принятого crc16
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
					USART_send_byte(3);											  // вызов функции передачи байта "3" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
					USART_speed = 3;											  // значение кода скорости передачи данных модуля USART ("3" - 38,4 кбит/с)
					USARTC1_BAUDCTRLB = 0b10111100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-5(в доп. коде) и BSEL[11:8]=0b1111
					USARTC1_BAUDCTRLA = 0b11100101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b00100000 (BSEL[11:0]=0b110011100101=3301) ("3" - 38,4 кбит/с)
				}
				else // иначе
				{
					USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
					USART_send_byte(3);											  // вызов функции передачи байта "3" кода скорости передачи данных модуля USART
					USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
					USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
					USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
					USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
					func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				}
				Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;
			}
			break; // выход из байта функции 0x41

		case 0x42:				  // если байт кода функции соответствует команде старта измерения-----------------------------------------------------------------начало функции 0x42
			USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
			{
				//_delay_ms(4000);

				func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
				twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
				func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
				//_delay_ms(2000);
				twi_BME280_read_TPH();				  // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
				func_compensate_TPH();				  // вызов функции вычисления компенсированных значений температуры, давления и влажности
				func_DS18B20_temperature_meas_read(); // вызов функции чтения измеренной температуры датчика DS18B20

				/*
					if ((DS18B20_T_full<Th_on) && (Status_error_DS18B20!=1)) //если текущая температура нагревателя меньше значения нижнего порога температуры и отсутствует ошибка связи с датчиком DS18B20
					{
					Nagrevatel_ON; //включение нагревателя
					}
					else
					{
					Nagrevatel_OFF; //отключение нагревателя
					}
				*/

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x42);			// вызов функции передачи байта кода функции модуля USART

				USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
				Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

				USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
				Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

				USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
				Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
			}

			else // иначе
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x42 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART

				USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
				Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

				USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
				Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

				USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
				Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x42

		case 0x43:							// если байт кода функции соответствует команде чтения метеоданных-----------------------------------------------------------------начало функции 0x43
			func_compare_crc16();			// вызов функции определения правильности принятого crc16
			func_packing_meteo();			// вызов функции упаковки метеоданных в массив
			USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
			USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

			if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
			{
				USART_send_byte(0x43); // вызов функции передачи байта кода функции модуля USART
			}
			else // иначе
			{
				USART_send_byte(0x43 + 0x80); // вызов функции передачи модифицированного байта кода функции модуля USART
			}

			for (uint8_t i = 0; i < 21; i++)
			{
				USART_send_byte(Mas_meteo[i]); // вызов функции передачи байта метеоданных
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x43

		case 0x44:				  // если байт кода функции соответствует команде калибровки анемометра-----------------------------------------------------------начало функции 0x44
			USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x44 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}
			else // иначе
			{
				if (Mas_crc16[3] == 0x00) // если байт данных равен 0x00
				{
					func_kalibrovka_usil();			// вызов функции калибровки усиления для 4-х каналов с параметром Umax (Umax определяет верхний порог в 8-разрядном коде для выборки с номером N_prohodov)
					func_kalibrovka_null();			// вызов функции калибровки нуля
					USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
					USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
					USART_send_byte(0x44);			// вызов функции передачи байта кода функции модуля USART
				}

				if ((Mas_crc16[3] == 0x01) || (Mas_crc16[3] == 0x02)) // если байт данных принимает значения 0x01 или 0x02
				{
					func_kalibrovka_veter(Mas_crc16[3], 100); // вызов функции калибровки с ветром для выбраной оси и направления при скорости эталонного ветра 100 дм/с
					USART_mode_transceiver(1);				  // функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
					USART_send_byte(USART_address);			  // вызов функции передачи байта адреса метеоблока М1 модуля USART
					USART_send_byte(0x44);					  // вызов функции передачи байта кода функции модуля USART
				}

				if (Mas_crc16[3] == 0x03) // если байт данных равен 0x03
				{
					func_baze_sbor_dannyh(1);		// вызов функции одиночного базового сбора данных с одним проходом
					USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
					USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
					USART_send_byte(0x44);			// вызов функции передачи байта кода функции модуля USART
				}
			}
			USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
			func_USART_send_crc16();				 // вызов функции передачи crc16 модуля USART
			// Status_error_anemometr=0; //обнуление статуса ошибки связи с анемометром
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x44

		case 0x45:				  // если байт кода функции соответствует команде сброса данных калибровки анемометра----------------------------------------------начало функции 0x45
			USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x45 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}
			else // иначе
			{
				if ((Mas_crc16[3] >= 0) && (Mas_crc16[3] < 0x07)) // если байт данных принимает значения от 0x00 до 0x06
				{
					eeprom_write_byte((uint8_t *)(Mas_crc16[3] + 0), 0); // сброс в eeprom по адресу (Mas_crc16[3]) статуса калибровки
				}

				func_eeprom_read();				// вызов функции чтения из eeprom данных калибровки
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x45);			// вызов функции передачи байта кода функции модуля USART
			}
			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x45

		case 0x46:				  // если байт кода функции соответствует команде чтения данных-----------------------------------------------------------------начало функции 0x46
			USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x46 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}

			else // иначе
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x46);			// вызов функции передачи байта кода функции модуля USART

				switch (Mas_crc16[3]) // если 3-й байт данных равен
				{
				case 0x00:							   // если байт соответствует чтению данных статуса калибровки анемометра
					USART_send_byte(status_kal_K0);	   // вызов функции передачи байта статуса калибровки без ветра
					USART_send_byte(status_kal_X);	   // вызов функции передачи байта статуса калибровки с ветром по оси X
					USART_send_byte(status_kal_Y);	   // вызов функции передачи байта статуса калибровки с ветром по оси Y
					USART_send_byte(status_kal_T);	   // вызов функции передачи байта статуса калибровки температуры и температуры подогрева метеоблока
					USART_send_byte(status_kal_Th_on); // вызов функции передачи байта статуса температуры включения подогрева метеоблока
					USART_send_byte(status_kal_H);	   // вызов функции передачи байта статуса калибровки влажности метеоблока
					USART_send_byte(status_kal_P);	   // вызов функции передачи байта статуса калибровки давления метеоблока
					break;

				case 0x01: // если байт соответствует чтению данных калибровки анемометра без ветра
					/*
						USART_send_byte(Mas_basedPD[0]); //вызов функции передачи байта усиления 1-го канала
						USART_send_byte(Mas_basedPD[1]); //вызов функции передачи байта усиления 2-го канала
						USART_send_byte(Mas_basedPD[2]); //вызов функции передачи байта усиления 3-го канала
						USART_send_byte(Mas_basedPD[3]); //вызов функции передачи байта усиления 4-го канала
					*/

					USART_send_byte(Mas_previousPD[0]); // вызов функции передачи байта усиления 1-го канала
					USART_send_byte(Mas_previousPD[1]); // вызов функции передачи байта усиления 2-го канала
					USART_send_byte(Mas_previousPD[2]); // вызов функции передачи байта усиления 3-го канала
					USART_send_byte(Mas_previousPD[3]); // вызов функции передачи байта усиления 4-го канала

					temp_C = (int16_t)(round((double)(dT_k0_k1_null) / 0.64)); // преобразование смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
					temp_C = (int16_t)(round((double)(dT_k2_k3_null) / 0.64)); // преобразование смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
					temp_C = (int16_t)(round((double)(dTx) / 6.4));			   // преобразование смещения доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
					temp_C = (int16_t)(round((double)(dTy) / 6.4));			   // преобразование смещения доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
					USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
					USART_send_byte((uint8_t)((uint16_t)(Tx) >> 8));		   // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси X (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)(Tx));							   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси X (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)((uint16_t)(Ty) >> 8));		   // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси Y (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)(Ty));							   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси Y (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)((uint16_t)(Ct) >> 8));		   // вызов функции передачи старшего байта скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с, uint16_t)
					USART_send_byte((uint8_t)(Ct));							   // вызов функции передачи младшего байта скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с, uint16_t)
					break;

				case 0x02:												   // если байт соответствует чтению данных калибровки анемометра с ветром
					USART_send_byte((uint8_t)(((uint16_t)(Sx_kal)) >> 8)); // вызов функции передачи старшего байта длины пути ультразвука по оси X при калибровке (в десятых долях мм, uint16_t)
					USART_send_byte((uint8_t)(Sx_kal));					   // вызов функции передачи младшего байта длины пути ультразвука по оси X при калибровке(в десятых долях мм, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Tx_kal)) >> 8)); // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси X при калибровке (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)(Tx_kal));					   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси X при калибровке (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Sy_kal)) >> 8)); // вызов функции передачи старшего байта длины пути ультразвука по оси Y при калибровке (в десятых долях мм, uint16_t)
					USART_send_byte((uint8_t)(Sy_kal));					   // вызов функции передачи младшего байта длины пути ультразвука по оси Y при калибровке (в десятых долях мм, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Ty_kal)) >> 8)); // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси Y при калибровке (в десятых долях мкс, uint16_t)
					USART_send_byte((uint8_t)(Ty_kal));					   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси Y при калибровке (в десятых долях мкс, uint16_t)
					break;

				case 0x03:													// если байт соответствует чтению калибровки метеоданных
					USART_send_byte((uint8_t)(((int16_t)(Tst_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Tst_low));					// вызов функции передачи младшего байта нижнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(((int16_t)(Tst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Tst_high));					// вызов функции передачи младшего байта верхнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(((int16_t)(Tm_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Tm_low));						// вызов функции передачи младшего байта нижнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(((int16_t)(Tm_high)) >> 8));	// вызов функции передачи старшего байта верхнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Tm_high));					// вызов функции передачи младшего байта верхнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(((int16_t)(Th_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Th_low));						// вызов функции передачи младшего байта нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(((int16_t)(Th_high)) >> 8));	// вызов функции передачи старшего байта верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Th_high));					// вызов функции передачи младшего байта верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Th_on >> 8));					// вызов функции передачи старшего байта верхнего значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
					USART_send_byte((uint8_t)(Th_on));						// вызов функции передачи младшего байта верхнего значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)

					USART_send_byte((uint8_t)(((uint16_t)(Hst_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения влажности эталона (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(Hst_low));					 // вызов функции передачи младшего байта нижнего значения влажности эталона (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Hst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения влажности эталона (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(Hst_high));					 // вызов функции передачи младшего байта верхнего значения влажности эталона (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Hm_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения влажности метеоблока (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(Hm_low));						 // вызов функции передачи младшего байта нижнего значения влажности метеоблока (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Hm_high)) >> 8));	 // вызов функции передачи старшего байта верхнего значения влажности метеоблока (в десятых долях процента, uint16_t)
					USART_send_byte((uint8_t)(Hm_high));					 // вызов функции передачи младшего байта верхнего значения влажности метеоблока (в десятых долях процента, uint16_t)

					USART_send_byte((uint8_t)(((uint16_t)(Pst_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(Pst_low));					 // вызов функции передачи младшего байта нижнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Pst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(Pst_high));					 // вызов функции передачи младшего байта верхнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Pm_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(Pm_low));						 // вызов функции передачи младшего байта нижнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(((uint16_t)(Pm_high)) >> 8));	 // вызов функции передачи старшего байта верхнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
					USART_send_byte((uint8_t)(Pm_high));					 // вызов функции передачи младшего байта верхнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
					break;

				case 0x04:							// если байт соответствует чтению одного цикла выборки времени импульсов анемометра
					for (uint8_t k = 0; k < 4; k++) // цикл по каналам с 1-го по 4-й
					{
						for (uint8_t j = 0; j < N_operativ; j++) // цикл по импульсам с 0-го по (N_operativ-1)
						{
							USART_send_byte((uint8_t)(Mas_timer_operativ[k][j] >> 8)); // вызов функции передачи старшего байта выборки времени импульса анемометра (в тактах микроконтроллера, uint16_t)
							USART_send_byte((uint8_t)(Mas_timer_operativ[k][j]));	   // вызов функции передачи младшего байта выборки времени импульса анемометра (в тактах микроконтроллера, uint16_t)
						}
					}
					break;

				case 0x05:							// если байт соответствует чтению одного цикла выборки амплитуд импульсов анемометра
					for (uint8_t k = 0; k < 4; k++) // цикл по каналам с 1-го по 4-й
					{
						for (uint8_t j = 0; j < N_operativ; j++) // цикл по импульсам с 0-го по (N_operativ-1)
						{
							USART_send_byte((uint8_t)(Mas_amplitude_operativ[k][j])); // вызов функции передачи байта выборки амплитуды импульса анемометра в 8-ми разрядном коде (uint8_t)
						}
					}
					break;
				}
			}
			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x46

		case 0x47:							 // если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x47
			for (uint8_t i = 0; i < 12; i++) // цикл от 0 по 11
			{
				USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
			}

			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x47 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}

			else // иначе
			{

				temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Tst_low
				eeprom_write_word((uint16_t *)60, temp_C);							 // запись в eeprom по адресу 60 значения Tst_low
				Tst_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Tst_high
				eeprom_write_word((uint16_t *)62, temp_C);							 // запись в eeprom по адресу 62 значения Tst_high
				Tst_high = (double)(temp_C);										 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Tm_low
				eeprom_write_word((uint16_t *)64, temp_C);							 // запись в eeprom по адресу 64 значения Tm_low
				Tm_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Tm_high
				eeprom_write_word((uint16_t *)66, temp_C);							  // запись в eeprom по адресу 66 значения Tm_high
				Tm_high = (double)(temp_C);											  // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[11])) << 8) + (int16_t)(Mas_crc16[12]); // восстановление Th_low
				eeprom_write_word((uint16_t *)68, temp_C);							   // запись в eeprom по адресу 68 значения Th_low
				Th_low = (double)(temp_C);											   // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[13])) << 8) + (int16_t)(Mas_crc16[14]); // восстановление Th_high
				eeprom_write_word((uint16_t *)70, temp_C);							   // запись в eeprom по адресу 70 значения Th_high
				Th_high = (double)(temp_C);											   // приведение к типу double

				eeprom_write_byte((uint8_t *)3, 1); // запись в eeprom по адресу 3 статуса калибровки температуры метеоблока
				func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x47);			// вызов функции передачи байта кода функции модуля USART
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x47

		case 0x48:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x48
			for (uint8_t i = 0; i < 4; i++) // цикл от 0 по 3
			{
				USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
			}

			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x48 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}

			else // иначе
			{
				Th_on = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Th_on
				if (Th_on < 400)													// если значение Th_on меньше 40 градусов Цельсия
				{
					eeprom_write_word((uint16_t *)72, Th_on); // запись в eeprom по адресу 72 значения Th_on
					eeprom_write_byte((uint8_t *)4, 1);		  // запись в eeprom по адресу 4 статуса температуры подогрева и серийного номера метеоблока
					func_eeprom_read();						  // вызов функции чтения из eeprom данных калибровки
				}
				serial_number = (((uint16_t)(Mas_crc16[5])) << 8) + (uint16_t)(Mas_crc16[6]); // восстановление серийного номера метеоблока
				eeprom_write_word((uint16_t *)102, serial_number);							  // запись в eeprom по адресу 102 значения serial_number

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x48);			// вызов функции передачи байта кода функции модуля USART
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x48

		case 0x49:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x49
			for (uint8_t i = 0; i < 8; i++) // цикл от 0 по 7
			{
				USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
			}

			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x49 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}

			else // иначе
			{
				temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Hst_low
				eeprom_write_word((uint16_t *)80, temp_C);							 // запись в eeprom по адресу 80 значения Hst_low
				Hst_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Hst_high
				eeprom_write_word((uint16_t *)82, temp_C);							 // запись в eeprom по адресу 82 значения Hst_high
				Hst_high = (double)(temp_C);										 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Hm_low
				eeprom_write_word((uint16_t *)84, temp_C);							 // запись в eeprom по адресу 84 значения Hm_low
				Hm_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Hm_high
				eeprom_write_word((uint16_t *)86, temp_C);							  // запись в eeprom по адресу 86 значения Hm_high
				Hm_high = (double)(temp_C);											  // приведение к типу double

				eeprom_write_byte((uint8_t *)5, 1); // запись в eeprom по адресу 5 статуса калибровки влажности метеоблока
				func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x49);			// вызов функции передачи байта кода функции модуля USART
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x49

		case 0x4A:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x4A
			for (uint8_t i = 0; i < 8; i++) // цикл от 0 по 7
			{
				USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
			}

			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x4A + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
			}

			else // иначе
			{
				temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Pst_low
				eeprom_write_word((uint16_t *)90, temp_C);							 // запись в eeprom по адресу 90 значения Pst_low
				Pst_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Pst_high
				eeprom_write_word((uint16_t *)92, temp_C);							 // запись в eeprom по адресу 92 значения Pst_high
				Pst_high = (double)(temp_C);										 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Pm_low
				eeprom_write_word((uint16_t *)94, temp_C);							 // запись в eeprom по адресу 94 значения Pm_low
				Pm_low = (double)(temp_C);											 // приведение к типу double

				temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Pm_high
				eeprom_write_word((uint16_t *)96, temp_C);							  // запись в eeprom по адресу 96 значения Pm_high
				Pm_high = (double)(temp_C);											  // приведение к типу double

				eeprom_write_byte((uint8_t *)6, 1); // запись в eeprom по адресу 6 статуса калибровки давления метеоблока
				func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x4A);			// вызов функции передачи байта кода функции модуля USART
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x4A

		case 0x4B:
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_mode_transceiver(1);
			if (Status_error_USART != 0)
			{
				USART_send_byte(USART_address);
				USART_send_byte(0x4B + 0x80);
			}
			else
			{
				Mas_basedPD[0] = Mas_crc16[3] == 0 ? Mas_basedPD[0] : Mas_crc16[3];
				Mas_basedPD[1] = Mas_crc16[4] == 0 ? Mas_basedPD[1] : Mas_crc16[4];
				Mas_basedPD[2] = Mas_crc16[5] == 0 ? Mas_basedPD[2] : Mas_crc16[5];
				Mas_basedPD[3] = Mas_crc16[6] == 0 ? Mas_basedPD[3] : Mas_crc16[6];
				ADC_porog = Mas_crc16[7] == 0 ? ADC_porog : Mas_crc16[7];
				USART_send_byte(USART_address);
				USART_send_byte(0x4B);
			}
			Status_error_USART = 0;
			USART_mode_transceiver(0);
			break;
		} // конец перечисления байтов функций
	}
	else
	{
		if (Mas_crc16[counter_buffer] == 0x00) // если принятый байт равен "0x00"
		{
			USART_get_byte();					   // считывание из приёмного буфера модуля USART байта кода функции
			if (Mas_crc16[counter_buffer] == 0x42) // если принятый байт равен "0x42"
			{
				USART_get_byte();	  // считывание из приёмного буфера модуля USART байта кода функции
				func_compare_crc16(); // вызов функции определения правильности принятого crc16

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
					twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
					func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
					twi_BME280_read_TPH();				   // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
					func_compensate_TPH();				   // вызов функции вычисления компенсированных значений температуры, давления и влажности
					func_DS18B20_temperature_meas_read();  // вызов функции чтения измеренной температуры датчика DS18B20
				}
				Status_error_DS18B20 = 0;	// обнуление статуса ошибки связи с датчиком DS18B20
				Status_error_BME280 = 0;	// обнуление статуса ошибки связи с модулем BME280
				Status_error_anemometr = 0; // обнуление статуса ошибки связи с анемометром
				Status_error_USART = 0;		// обнуление переменной статуса ошибки модуля USART
			}
		}
	}
	// interrupt_ON; //глобальное разрешение прерываний
	// interrupt_ON(); //вызов функции разрешения прерываний
	USARTC1_CTRLA = USART_RXCINTLVL_LO_gc; // установка низкого уровня прерываний по завершению приёма
	RTC_ON;								   // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
	// Timer_heating_control_ON; //включение таймера-счётчика управления подогревом
}
//---------------------------------------------------------------------------------------------------------------------------конец обработки прерывания модуля USART по завершению приёма данных
//---------------------------------------------------------------------------------------------------------------------------- Прерывания (конец)

//---------------------------------------------------------------------------------------------------------------------------- Основная функция (начало)
// —————————————
int main(void)
{
	// osc32MHz_ini(); //вызов функции инициализации системной частоты 32МГц
	// osc16MHz_ini(); //вызов функции инициализации системной частоты 16МГц
	oscPLL_ini(); // вызов функции инициализации системной частоты PLL

	// func_eeprom_clear(); //вызов функции очистки EEPROM

	func_eeprom_read_ID(); // вызов функции чтения из eeprom данных ID (версия прошивки и серийный номер метеоблока)
	func_eeprom_read();	   // вызов функции чтения из eeprom данных калибровки
	port_ini();			   // инициализация портов
	// RTC_1kHz_ini(); //функция инициализации счётчика реального времени с внутренним генератором частотой 1 kГц
	ADC_Init();						 // вызов функции иницилизации АЦП
	interrupt_ini();				 // вызов функции инициализации прерываний
	LCD_ini();						 // инициализация дисплея
	clearlcd();						 // очистка дисплея
	setpos(0, 0);					 // устанавливаем курсор в начальное положение первой строки
	str_lcd("   HaАa»o paІoїГ    "); // выводим надпись "   Начало работы    "
	twi_master_ini();				 // вызов функции инициализации ведущего модуля twi
	twi_master_BME280_ini();		 // вызов функции ведущего модуля twi для инициализации BME280
	_delay_ms(100);					 // задержка 100 мс
	twi_BME280_read1_kalibr();		 // вызов 1-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	twi_BME280_read2_kalibr();		 // вызов 2-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	twi_BME280_read3_kalibr();		 // вызов 3-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
	repacking_BME280_kalibr();		 // вызов функции распаковки данных калибровки c датчика BME280
	func_DS18B20_ini();				 // вызов функции инициализации датчика DS18B20
	USART_ini();					 // вызов функции нициализации модуля USART
	func_izm_ADC_virtual_null();	 // вызов функции измерения виртуального нуля АЦП
	osc32kHz_RTC_ini();				 // вызов функции включения внешнего генератора частоты 32kГц счётчика реального времени

	for (uint8_t i = 0; i < 100; i++)
	{
		if (Marker_button == 0) // если с момента включения анемометра не была нажата кнопка №3 (с панели подключаемого LCD-модуля)
		{
			_delay_ms(40); // задержка 40 мс
		}
		else // если кнопку отпустили раньше 4 с
		{
			break; // выход из цикла
		}
	}

	if (Marker_button == 0) // если в течении 5 с кнопка №3 не была нажата
	{
		interrupt_button_OFF;			 // запрет прерываний по нажатию кнопок
		clearlcd();						 // очистка дисплея
		setpos(0, 0);					 // устанавливаем курсор в начальное положение первой строки
		str_lcd("   OcЅoіЅo№ pe¶ёј   "); // выводим надпись "   Основной режим   "
		setpos(0, 1);					 // устанавливаем курсор в начальное положение второй строки
		str_lcd(" (єЅoѕєё ЅeaєїёіЅГ) "); // выводим надпись " (кнопки неактивны) "
		// Timer_heating_control_ON; //включение таймера-счётчика управления подогревом

		while (1) // нахождение внутри основного рабочего цикла
		{
			/*
			func_DS18B20_temperature_meas_start(); //вызов функции старта измерения температуры датчика DS18B20
			_delay_ms(1000);
			func_DS18B20_temperature_meas_read(); //вызов функции чтения измеренной температуры датчика DS18B20
				if ((DS18B20_T_full<Th_on) && (Status_error_DS18B20!=1)) //если текущая температура нагревателя меньше значения нижнего порога температуры и отсутствует ошибка связи с датчиком DS18B20
				{
				Nagrevatel_ON; //включение нагревателя
				}
				else
				{
				Nagrevatel_OFF; //отключение нагревателя
				}
			*/
			_delay_ms(10); // задержка 10 мс
		}
	}

	while (1) // попадаем в бесконечный цикл отладки
	{
		if (vyp_menu != 0) // если vyp_menu не равно 0
		{
			switch (vyp_menu)
			{
			case 1000:							 // если tek_menu равно 1000
				clearlcd();						 // очистка дисплея
				setpos(0, 0);					 // устанавливаем курсор в начальное положение второй строки
				str_lcd(" Hacїpo№єё cІpoБeЅГ "); // выводим надпись " Настройки сброшены "
				func_kalibrovka_reset_K0();		 // вызов функции сброса калибровки без ветра
				func_kalibrovka_reset_XY();		 // вызов функции сброса калибровки с ветром
				func_eeprom_read();				 // вызов функции чтения из eeprom данных калибровки
				_delay_ms(2000);				 // задержка 2 с
				vyp_menu = 0;					 // vyp_menu присвоить значение 0 (отменить дальнейшее выполнение текущей подпрограммы)
				func_otobr_menu();				 // вызов функции отображения меню
				break;

			case 2000:					 // если tek_menu равно 2000
				while (vyp_menu == 2000) // пока vyp_menu равно 2000 идёт циклическое измерение данных температуры, давления и влажности с датчика BME280
				{
					Status_error_BME280 = 0;		// обнуление переменной статуса ошибки связи с модулем BME280
					twi_master_BME280_ini();		// вызов функции ведущего модуля twi для инициализации BME280
					_delay_ms(100);					// задержка 100 мс
					twi_BME280_read1_kalibr();		// вызов 1-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
					twi_BME280_read2_kalibr();		// вызов 2-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
					twi_BME280_read3_kalibr();		// вызов 3-й функции мастер-приёмник модуля twi для чтения данных калибровки BME280
					repacking_BME280_kalibr();		// вызов функции распаковки данных калибровки c датчика BME280
					twi_master_BME280_start_meas(); // вызов функции старта измерения BME280
					_delay_ms(100);					// задержка 100 мс
					twi_BME280_read_TPH();			// вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
					func_compensate_TPH();			// вызов функции вычисления компенсированных значений температуры, давления и влажности
					func_vyvod_TPH();				// вызов функции вывода данных температуры, давления и влажности с датчика BME280
					_delay_ms(3000);				// задержка 1 с
				}
				break;

			case 3000:					 // если tek_menu равно 3000
				while (vyp_menu == 3000) // пока vyp_menu равно 3000 идёт циклическое измерение данных температуры с датчика DS18B20
				{
					Status_error_DS18B20 = 0;			   // обнуление переменной статуса ошибки связи с датчиком DS18B20
					func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
					_delay_ms(800);						   // задержка 800 мc (необходимая задержка датчика DS18B20 для получения актуального 12-разрядного значения температуры)
					func_DS18B20_temperature_meas_read();  // вызов чтения измеренной температуры датчика DS18B20
					func_vyvod_T();						   // вызов функции вывода данных температуры датчика DS18B20
					_delay_ms(3000);					   // задержка 3 с
				}
				break;

			case 4100:						// если tek_menu равно 4100
				func_vyvod_skorost_Vx_Vy(); // вызов функции вывода скорости ветра по осям в дм/с
				while (vyp_menu == 4100)	// ожидание, пока vyp_menu равно 4100
				{
					func_skorost(0);			// вызов функции скорости ветра в дм/с
					_delay_ms(3000);			// задержка 3 с
					func_vyvod_skorost_Vx_Vy(); // вызов функции вывода скорости ветра по осям в дм/с
					_delay_ms(10);				// задержка 10 мкс
				}
				func_otobr_menu(); // вызов функции отображения меню
				break;

			case 4200:						// если tek_menu равно 4200
				Status_error_anemometr = 0; // обнуление переменной статуса ошибки связи с анемометром
				func_kalibrovka_usil();		// вызов функции калибровки усиления для 4-х каналов
				func_vyvod_kalibr_usil();	// вызов функции вывода калибровки усиления (для 4-х каналов)
				_delay_ms(4000);			// задержка 4 с
				func_kalibrovka_null();		// вызов функции калибровки нуля
				func_vyvod_kalibr_null();	// вызов функции вывода калибровки нуля (для оси Х и оси У разница времени без ветра в мкс)
				while (vyp_menu == 4200)	// ожидание, пока vyp_menu равно 4200
				{
					_delay_ms(10); // задержка 10 мкс
				}
				func_otobr_menu(); // вызов функции отображения меню
				break;

			case 4300:					  // если tek_menu равно 4300
				func_vyvod_kalibr_usil(); // вызов функции вывода калибровки усиления (для 4-х каналов)
				_delay_ms(6000);		  // задержка 6 с
				func_vyvod_kalibr_null(); // вызов функции вывода калибровки нуля (для оси Х и оси У разница времени без ветра в мкс)
				while (vyp_menu == 4300)  // ожидание, пока vyp_menu равно 4300
				{
					_delay_ms(10); // задержка 10 мкс
				}
				func_otobr_menu(); // вызов функции отображения меню
				break;

			case 4400:							 // если tek_menu равно 4500
				clearlcd();						 // очистка дисплея
				setpos(0, 0);					 // устанавливаем курсор в начальное положение второй строки
				str_lcd(" ЎeЅepaїop ·aѕyжeЅ  "); // выводим надпись " Генератор запущен  "
				while (vyp_menu == 4400)		 // пока vyp_menu равно 4500 запускаем функцию генератора
				{
					for (uint8_t k = 0; k < 4; k++) // цикл по 4-м каналам
					{
						Potentiometr_set(Mas_basedPD[k]); // установка значения потенциометра для усиления 0-го уровня
						kanal_select(k);				  // вызов функции включения k-го канала
						generator();					  // вызов функции запуска одного периода импульса частотой 200 кГц (длительность полупериода - 1,25 мкс)
						_delay_ms(3);					  // задержка 3 мс
					}
					_delay_ms(10); // задержка 10 мс
				}
				func_otobr_menu(); // вызов функции отображения меню
				break;
			}
		}
		_delay_ms(100); // задержка 100 мс
	}
	// ждём очередного нажатия кнопки
}
// —————————————
//---------------------------------------------------------------------------------------------------------------------------- Основная функция (конец)