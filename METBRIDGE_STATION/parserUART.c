//---------------------------------------------------------------------------------------------------------------------------начало обработки прерывания модуля USART по завершению приёма данных
// —————————————
ISR(USARTC1_RXC_vect) // вектор обработки прерывания модуля USART_C1 по завершению приёма данных
{
	USART_get_byte(); // считывание из приёмного буфера модуля USART байта адреса

	if (Mas_crc16[counter_buffer] == USART_address) // если принятый байт совпадает с адресом метеоблока М1
	{
		// USART_get_byte(); // считывание из приёмного буфера модуля USART байта кода функции

		switch (Mas_crc16[counter_buffer]) // начало перечисления байтов функций
		{
		// case 0x41:			  // если байт кода функции соответствует команде присутствия-----------------------------------------------------------------начало функции 0x41
		// 	USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
		// 	break; // выход из байта функции 0x42

		case 0x42:				  // если байт кода функции соответствует команде старта измерения-----------------------------------------------------------------начало функции 0x42
			USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
			func_compare_crc16(); // вызов функции определения правильности принятого crc16

			if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
			{
				//_delay_ms(4000);

				func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
				twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
				func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
				//_delay_ms(2000);
				twi_BME280_read_TPH();				  // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
				func_compensate_TPH();				  // вызов функции вычисления компенсированных значений температуры, давления и влажности
				func_DS18B20_temperature_meas_read(); // вызов функции чтения измеренной температуры датчика DS18B20

				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x42);			// вызов функции передачи байта кода функции модуля USART

				USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
				Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

				USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
				Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

				USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
				Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
			}

			else // иначе
			{
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				USART_send_byte(0x42 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART

				USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
				Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

				USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
				Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

				USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
				Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x42

		case 0x43:							// если байт кода функции соответствует команде чтения метеоданных-----------------------------------------------------------------начало функции 0x43
			func_compare_crc16();			// вызов функции определения правильности принятого crc16
			func_packing_meteo();			// вызов функции упаковки метеоданных в массив
			USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
			USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

			if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
			{
				USART_send_byte(0x43); // вызов функции передачи байта кода функции модуля USART
			}
			else // иначе
			{
				USART_send_byte(0x43 + 0x80); // вызов функции передачи модифицированного байта кода функции модуля USART
			}

			for (uint8_t i = 0; i < 21; i++)
			{
				USART_send_byte(Mas_meteo[i]); // вызов функции передачи байта метеоданных
			}

			func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
			Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
			USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
			break;					   // выход из байта функции 0x43

		case 0x4B:
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_get_byte();
			USART_mode_transceiver(1);
			if (Status_error_USART != 0)
			{
				USART_send_byte(USART_address);
				USART_send_byte(0x4B + 0x80);
			}
			else
			{
				Mas_basedPD[0] = Mas_crc16[3] == 0 ? Mas_basedPD[0] : Mas_crc16[3];
				Mas_basedPD[1] = Mas_crc16[4] == 0 ? Mas_basedPD[1] : Mas_crc16[4];
				Mas_basedPD[2] = Mas_crc16[5] == 0 ? Mas_basedPD[2] : Mas_crc16[5];
				Mas_basedPD[3] = Mas_crc16[6] == 0 ? Mas_basedPD[3] : Mas_crc16[6];
				ADC_porog = Mas_crc16[7] == 0 ? ADC_porog : Mas_crc16[7];
				USART_send_byte(USART_address);
				USART_send_byte(0x4B);
			}
			Status_error_USART = 0;
			USART_mode_transceiver(0);
			break;
		} // конец перечисления байтов функций
	}
	else
	{
		if (Mas_crc16[counter_buffer] == 0x00) // если принятый байт равен "0x00"
		{
			USART_get_byte();					   // считывание из приёмного буфера модуля USART байта кода функции
			if (Mas_crc16[counter_buffer] == 0x42) // если принятый байт равен "0x42"
			{
				USART_get_byte();	  // считывание из приёмного буфера модуля USART байта кода функции
				func_compare_crc16(); // вызов функции определения правильности принятого crc16

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
					twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
					func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
					twi_BME280_read_TPH();				   // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
					func_compensate_TPH();				   // вызов функции вычисления компенсированных значений температуры, давления и влажности
					func_DS18B20_temperature_meas_read();  // вызов функции чтения измеренной температуры датчика DS18B20
				}
				Status_error_DS18B20 = 0;	// обнуление статуса ошибки связи с датчиком DS18B20
				Status_error_BME280 = 0;	// обнуление статуса ошибки связи с модулем BME280
				Status_error_anemometr = 0; // обнуление статуса ошибки связи с анемометром
				Status_error_USART = 0;		// обнуление переменной статуса ошибки модуля USART
			}
		}
	}
case default: // если байт кода функции соответствует команде чтения метеоданных-----------------------------------------------------------------начало функции 0x43
	break;	  // выход из байта функции 0x43

	// interrupt_ON; //глобальное разрешение прерываний
	// interrupt_ON(); //вызов функции разрешения прерываний
	USARTC1_CTRLA = USART_RXCINTLVL_LO_gc; // установка низкого уровня прерываний по завершению приёма
	RTC_ON;								   // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
										   // Timer_heating_control_ON; //включение таймера-счётчика управления подогревом
}
}
//---------------------------------------------------------------------------------------------------------------------------конец обработки прерывания модуля USART по завершению приёма данных

// —————————————
uint16_t func_calc_crc16(uint8_t *Mas_crc16, uint8_t size) // функция вычисления crc16 (первый аргумент-указатель на элемент массива Mas_crc16, второй - задаёт число элементов массива)
{
	uint16_t crc16 = 0xFFFF; // объявление переменной для хранения результата вычисления crc16 с заданием начального значения

	while (size--) // цикл, пока число элементов массива не равно 0
	{
		crc16 ^= *Mas_crc16++;
		for (uint8_t i = 0; i < 8; i++)
		{
			if (crc16 & 0x01) // если младший бит crc16 равен единице
			{
				crc16 = (crc16 >> 1) ^ 0xA001; // вычисление текущего значения crc16
			}
			else // иначе
			{
				crc16 = crc16 >> 1; // логический сдвиг вправо текущего значения crc16
			}
		}
	}
	return crc16; // возврат функцией значения crc16
}
// —————————————

//---------------------------------------------------------------------------------------------------------------------------начало обработки прерывания модуля USART по завершению приёма данных
// —————————————
ISR(USARTC1_RXC_vect) // вектор обработки прерывания модуля USART_C1 по завершению приёма данных
{
	int16_t temp_C; // локальная переменная
	// Timer_heating_control_OFF; //выключение таймера-счётчика управления подогревом
	RTC_OFF;			// запрет прерывания счетчика реального времени RTC по совпадению
	RTC_CNT = 0;		// обнуление RTC
	counter_buffer = 0; // обнуление переменной для хранения счётчика принятых/переданных байтов

	// interrupt_OFF; //глобальный запрет прерываний
	// interrupt_OFF(); //вызов функции запрета прерываний
	USARTC1_CTRLA = 0; // запрет прерываний модуля USART
	USART_get_byte();  // считывание из приёмного буфера модуля USART байта адреса

	if (Mas_crc16[counter_buffer] == USART_address) // если принятый байт совпадает с адресом метеоблока М1
	{
		/*
		USART_mode_transceiver(1); //функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
		USART_send_byte(0x25); //вызов функции передачи байта адреса метеоблока М1 модуля USART
		USART_mode_transceiver(0); //функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
		USARTC1_CTRLA = USART_RXCINTLVL_LO_gc; //установка низкого уровня прерываний по завершению приёма
		return;
		*/

		USART_get_byte(); // считывание из приёмного буфера модуля USART байта кода функции

		switch (Mas_crc16[counter_buffer]) // начало перечисления байтов функций
		{
		case 0x41:			  // если байт кода функции соответствует команде присутствия-----------------------------------------------------------------начало функции 0x41
			USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных

			switch (Mas_crc16[counter_buffer])
			{
				// case 0x00:							// если байт данных равен 0x00
				// 	func_compare_crc16();			// вызов функции определения правильности принятого crc16
				// 	USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 	USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				// 	if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				// 	{
				// 		USART_send_byte(0x41); // вызов функции передачи байта кода функции модуля USART
				// 	}
				// 	else // иначе
				// 	{
				// 		USART_send_byte(0x41 + 0x80); // вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}
				// 	USART_send_byte(USART_speed);								  // вызов функции передачи текущего байта кода скорости передачи данных модуля USART
				// 	USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 	USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 	USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 	USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 	func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;										  // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0);									  // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;

				// case 0x01:							// если байт данных равен 0x01
				// 	func_compare_crc16();			// вызов функции определения правильности принятого crc16
				// 	USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 	USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				// 	if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				// 	{
				// 		USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
				// 		USART_send_byte(1);											  // вызов функции передачи байта "1" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 		USART_speed = 1;											  // значение кода скорости передачи данных модуля USART ("1" - 9,6 кбит/с)
				// 		USARTC1_BAUDCTRLB = 0b11011100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-3(в доп. коде) и BSEL[11:8]=0b1100
				// 		USARTC1_BAUDCTRLA = 0b11111101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11111101 (BSEL[11:0]=0b110011111101=3325) ("1" - 9,6 кбит/с)
				// 	}
				// 	else // иначе
				// 	{
				// 		USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
				// 		USART_send_byte(1);											  // вызов функции передачи байта "1" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 	}
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;

				// case 0x02:							// если байт данных равен 0x02
				// 	func_compare_crc16();			// вызов функции определения правильности принятого crc16
				// 	USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 	USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				// 	if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				// 	{
				// 		USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
				// 		USART_send_byte(2);											  // вызов функции передачи байта "2" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 		USART_speed = 2;											  // значение кода скорости передачи данных модуля USART ("2" - 19,2 кбит/с)
				// 		USARTC1_BAUDCTRLB = 0b11001100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-4(в доп. коде) и BSEL[11:8]=0b1100
				// 		USARTC1_BAUDCTRLA = 0b11111101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b11110101 (BSEL[11:0]=0b110011110101=3317) ("2" - 19,2 кбит/с)
				// 	}
				// 	else // иначе
				// 	{
				// 		USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
				// 		USART_send_byte(2);											  // вызов функции передачи байта "2" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 	}
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;

				// case 0x03:							// если байт данных равен 0x03
				// 	func_compare_crc16();			// вызов функции определения правильности принятого crc16
				// 	USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 	USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				// 	if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				// 	{
				// 		USART_send_byte(0x41);										  // вызов функции передачи байта кода функции модуля USART
				// 		USART_send_byte(3);											  // вызов функции передачи байта "3" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 		USART_speed = 3;											  // значение кода скорости передачи данных модуля USART ("3" - 38,4 кбит/с)
				// 		USARTC1_BAUDCTRLB = 0b10111100;								  // запись в регистр скорости BAUDCTRLB значений BSCALE[3:0]=-5(в доп. коде) и BSEL[11:8]=0b1111
				// 		USARTC1_BAUDCTRLA = 0b11100101;								  // запись в регистр скорости BAUDCTRLA значения  BSEL[7:0]=0b00100000 (BSEL[11:0]=0b110011100101=3301) ("3" - 38,4 кбит/с)
				// 	}
				// 	else // иначе
				// 	{
				// 		USART_send_byte(0x41 + 0x80);								  // вызов функции передачи модифицированного байта кода функции модуля USART
				// 		USART_send_byte(3);											  // вызов функции передачи байта "3" кода скорости передачи данных модуля USART
				// 		USART_send_byte(program_version_number);					  // вызов функции передачи номера версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte(program_variant_number);					  // вызов функции передачи номера варианта версии прошивки метеоблока М1 модуля USART
				// 		USART_send_byte((uint8_t)(((uint16_t)(serial_number)) >> 8)); // вызов функции передачи старшего байта серийного номера метеоблока М1 (uint16_t)
				// 		USART_send_byte((uint8_t)(serial_number));					  // вызов функции передачи младшего байта серийного номера метеоблока М1 (uint16_t)
				// 		func_USART_send_crc16();									  // вызов функции передачи crc16 модуля USART
				// 	}
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;
				// }
				// break; // выход из байта функции 0x41

			case 0x42:				  // если байт кода функции соответствует команде старта измерения-----------------------------------------------------------------начало функции 0x42
				USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
				func_compare_crc16(); // вызов функции определения правильности принятого crc16

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					//_delay_ms(4000);

					func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
					twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
					func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
					//_delay_ms(2000);
					twi_BME280_read_TPH();				  // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
					func_compensate_TPH();				  // вызов функции вычисления компенсированных значений температуры, давления и влажности
					func_DS18B20_temperature_meas_read(); // вызов функции чтения измеренной температуры датчика DS18B20

					/*
						if ((DS18B20_T_full<Th_on) && (Status_error_DS18B20!=1)) //если текущая температура нагревателя меньше значения нижнего порога температуры и отсутствует ошибка связи с датчиком DS18B20
						{
						Nagrevatel_ON; //включение нагревателя
						}
						else
						{
						Nagrevatel_OFF; //отключение нагревателя
						}
					*/

					USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
					USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
					USART_send_byte(0x42);			// вызов функции передачи байта кода функции модуля USART

					USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
					Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

					USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
					Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

					USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
					Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
				}

				else // иначе
				{
					USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
					USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
					USART_send_byte(0x42 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART

					USART_send_byte(Status_error_DS18B20); // вызов функции передачи байта статуса ошибки связи с датчиком DS18B20
					Status_error_DS18B20 = 0;			   // обнуление статуса ошибки связи с датчиком DS18B20

					USART_send_byte(Status_error_BME280); // вызов функции передачи байта статуса ошибки связи с модулем BME280
					Status_error_BME280 = 0;			  // обнуление статуса ошибки связи с модулем BME280

					USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
					Status_error_anemometr = 0;				 // обнуление статуса ошибки связи с анемометром
				}

				func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;					   // выход из байта функции 0x42

			case 0x43:							// если байт кода функции соответствует команде чтения метеоданных-----------------------------------------------------------------начало функции 0x43
				func_compare_crc16();			// вызов функции определения правильности принятого crc16
				func_packing_meteo();			// вызов функции упаковки метеоданных в массив
				USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART

				if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
				{
					USART_send_byte(0x43); // вызов функции передачи байта кода функции модуля USART
				}
				else // иначе
				{
					USART_send_byte(0x43 + 0x80); // вызов функции передачи модифицированного байта кода функции модуля USART
				}

				for (uint8_t i = 0; i < 21; i++)
				{
					USART_send_byte(Mas_meteo[i]); // вызов функции передачи байта метеоданных
				}

				func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				break;					   // выход из байта функции 0x43

				// case 0x44:				  // если байт кода функции соответствует команде калибровки анемометра-----------------------------------------------------------начало функции 0x44
				// 	USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x44 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}
				// 	else // иначе
				// 	{
				// 		if (Mas_crc16[3] == 0x00) // если байт данных равен 0x00
				// 		{
				// 			func_kalibrovka_usil();			// вызов функции калибровки усиления для 4-х каналов с параметром Umax (Umax определяет верхний порог в 8-разрядном коде для выборки с номером N_prohodov)
				// 			func_kalibrovka_null();			// вызов функции калибровки нуля
				// 			USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 			USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 			USART_send_byte(0x44);			// вызов функции передачи байта кода функции модуля USART
				// 		}

				// 		if ((Mas_crc16[3] == 0x01) || (Mas_crc16[3] == 0x02)) // если байт данных принимает значения 0x01 или 0x02
				// 		{
				// 			func_kalibrovka_veter(Mas_crc16[3], 100); // вызов функции калибровки с ветром для выбраной оси и направления при скорости эталонного ветра 100 дм/с
				// 			USART_mode_transceiver(1);				  // функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 			USART_send_byte(USART_address);			  // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 			USART_send_byte(0x44);					  // вызов функции передачи байта кода функции модуля USART
				// 		}

				// 		if (Mas_crc16[3] == 0x03) // если байт данных равен 0x03
				// 		{
				// 			func_baze_sbor_dannyh(1);		// вызов функции одиночного базового сбора данных с одним проходом
				// 			USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 			USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 			USART_send_byte(0x44);			// вызов функции передачи байта кода функции модуля USART
				// 		}
				// 	}
				// 	USART_send_byte(Status_error_anemometr); // вызов функции передачи байта статуса ошибки связи с анемометром
				// 	func_USART_send_crc16();				 // вызов функции передачи crc16 модуля USART
				// 	// Status_error_anemometr=0; //обнуление статуса ошибки связи с анемометром
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x44

				// case 0x45:				  // если байт кода функции соответствует команде сброса данных калибровки анемометра----------------------------------------------начало функции 0x45
				// 	USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x45 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}
				// 	else // иначе
				// 	{
				// 		if ((Mas_crc16[3] >= 0) && (Mas_crc16[3] < 0x07)) // если байт данных принимает значения от 0x00 до 0x06
				// 		{
				// 			eeprom_write_byte((uint8_t *)(Mas_crc16[3] + 0), 0); // сброс в eeprom по адресу (Mas_crc16[3]) статуса калибровки
				// 		}

				// 		func_eeprom_read();				// вызов функции чтения из eeprom данных калибровки
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x45);			// вызов функции передачи байта кода функции модуля USART
				// 	}
				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x45

				// case 0x46:				  // если байт кода функции соответствует команде чтения данных-----------------------------------------------------------------начало функции 0x46
				// 	USART_get_byte();	  // считывание из приёмного буфера модуля USART байта данных
				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x46 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}

				// 	else // иначе
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x46);			// вызов функции передачи байта кода функции модуля USART

				// 		switch (Mas_crc16[3]) // если 3-й байт данных равен
				// 		{
				// 		case 0x00:							   // если байт соответствует чтению данных статуса калибровки анемометра
				// 			USART_send_byte(status_kal_K0);	   // вызов функции передачи байта статуса калибровки без ветра
				// 			USART_send_byte(status_kal_X);	   // вызов функции передачи байта статуса калибровки с ветром по оси X
				// 			USART_send_byte(status_kal_Y);	   // вызов функции передачи байта статуса калибровки с ветром по оси Y
				// 			USART_send_byte(status_kal_T);	   // вызов функции передачи байта статуса калибровки температуры и температуры подогрева метеоблока
				// 			USART_send_byte(status_kal_Th_on); // вызов функции передачи байта статуса температуры включения подогрева метеоблока
				// 			USART_send_byte(status_kal_H);	   // вызов функции передачи байта статуса калибровки влажности метеоблока
				// 			USART_send_byte(status_kal_P);	   // вызов функции передачи байта статуса калибровки давления метеоблока
				// 			break;

				// 		case 0x01: // если байт соответствует чтению данных калибровки анемометра без ветра
				// 			/*
				// 				USART_send_byte(Mas_basedPD[0]); //вызов функции передачи байта усиления 1-го канала
				// 				USART_send_byte(Mas_basedPD[1]); //вызов функции передачи байта усиления 2-го канала
				// 				USART_send_byte(Mas_basedPD[2]); //вызов функции передачи байта усиления 3-го канала
				// 				USART_send_byte(Mas_basedPD[3]); //вызов функции передачи байта усиления 4-го канала
				// 			*/

				// 			USART_send_byte(Mas_previousPD[0]); // вызов функции передачи байта усиления 1-го канала
				// 			USART_send_byte(Mas_previousPD[1]); // вызов функции передачи байта усиления 2-го канала
				// 			USART_send_byte(Mas_previousPD[2]); // вызов функции передачи байта усиления 3-го канала
				// 			USART_send_byte(Mas_previousPD[3]); // вызов функции передачи байта усиления 4-го канала

				// 			temp_C = (int16_t)(round((double)(dT_k0_k1_null) / 0.64)); // преобразование смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта смещения при нулевом ветре по оси X (в сотых долях мкс, int16_t)
				// 			temp_C = (int16_t)(round((double)(dT_k2_k3_null) / 0.64)); // преобразование смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта смещения при нулевом ветре по оси Y (в сотых долях мкс, int16_t)
				// 			temp_C = (int16_t)(round((double)(dTx) / 6.4));			   // преобразование смещения доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта доп. задержки прихода пачки импульсов по оси X (в десятых долях мкс, int16_t)
				// 			temp_C = (int16_t)(round((double)(dTy) / 6.4));			   // преобразование смещения доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C >> 8));				   // вызов функции передачи старшего байта доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)(temp_C));						   // вызов функции передачи младшего байта доп. задержки прихода пачки импульсов по оси Y (в десятых долях мкс, int16_t)
				// 			USART_send_byte((uint8_t)((uint16_t)(Tx) >> 8));		   // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси X (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)(Tx));							   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси X (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)((uint16_t)(Ty) >> 8));		   // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси Y (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)(Ty));							   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси Y (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)((uint16_t)(Ct) >> 8));		   // вызов функции передачи старшего байта скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с, uint16_t)
				// 			USART_send_byte((uint8_t)(Ct));							   // вызов функции передачи младшего байта скорости ультразвука в воздухе, рассчитанной по температуре (в дм/с, uint16_t)
				// 			break;

				// 		case 0x02:												   // если байт соответствует чтению данных калибровки анемометра с ветром
				// 			USART_send_byte((uint8_t)(((uint16_t)(Sx_kal)) >> 8)); // вызов функции передачи старшего байта длины пути ультразвука по оси X при калибровке (в десятых долях мм, uint16_t)
				// 			USART_send_byte((uint8_t)(Sx_kal));					   // вызов функции передачи младшего байта длины пути ультразвука по оси X при калибровке(в десятых долях мм, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Tx_kal)) >> 8)); // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси X при калибровке (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)(Tx_kal));					   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси X при калибровке (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Sy_kal)) >> 8)); // вызов функции передачи старшего байта длины пути ультразвука по оси Y при калибровке (в десятых долях мм, uint16_t)
				// 			USART_send_byte((uint8_t)(Sy_kal));					   // вызов функции передачи младшего байта длины пути ультразвука по оси Y при калибровке (в десятых долях мм, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Ty_kal)) >> 8)); // вызов функции передачи старшего байта общей задержки прихода пачки импульсов по оси Y при калибровке (в десятых долях мкс, uint16_t)
				// 			USART_send_byte((uint8_t)(Ty_kal));					   // вызов функции передачи младшего байта общей задержки прихода пачки импульсов по оси Y при калибровке (в десятых долях мкс, uint16_t)
				// 			break;

				// 		case 0x03:													// если байт соответствует чтению калибровки метеоданных
				// 			USART_send_byte((uint8_t)(((int16_t)(Tst_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Tst_low));					// вызов функции передачи младшего байта нижнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(((int16_t)(Tst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Tst_high));					// вызов функции передачи младшего байта верхнего значения температуры эталона (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(((int16_t)(Tm_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Tm_low));						// вызов функции передачи младшего байта нижнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(((int16_t)(Tm_high)) >> 8));	// вызов функции передачи старшего байта верхнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Tm_high));					// вызов функции передачи младшего байта верхнего значения температуры метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(((int16_t)(Th_low)) >> 8));	// вызов функции передачи старшего байта нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Th_low));						// вызов функции передачи младшего байта нижнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(((int16_t)(Th_high)) >> 8));	// вызов функции передачи старшего байта верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Th_high));					// вызов функции передачи младшего байта верхнего значения температуры подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Th_on >> 8));					// вызов функции передачи старшего байта верхнего значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)
				// 			USART_send_byte((uint8_t)(Th_on));						// вызов функции передачи младшего байта верхнего значения температуры включения подогрева метеоблока (в десятых долях градуса Цельсия, int16_t)

				// 			USART_send_byte((uint8_t)(((uint16_t)(Hst_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения влажности эталона (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(Hst_low));					 // вызов функции передачи младшего байта нижнего значения влажности эталона (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Hst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения влажности эталона (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(Hst_high));					 // вызов функции передачи младшего байта верхнего значения влажности эталона (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Hm_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения влажности метеоблока (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(Hm_low));						 // вызов функции передачи младшего байта нижнего значения влажности метеоблока (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Hm_high)) >> 8));	 // вызов функции передачи старшего байта верхнего значения влажности метеоблока (в десятых долях процента, uint16_t)
				// 			USART_send_byte((uint8_t)(Hm_high));					 // вызов функции передачи младшего байта верхнего значения влажности метеоблока (в десятых долях процента, uint16_t)

				// 			USART_send_byte((uint8_t)(((uint16_t)(Pst_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(Pst_low));					 // вызов функции передачи младшего байта нижнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Pst_high)) >> 8)); // вызов функции передачи старшего байта верхнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(Pst_high));					 // вызов функции передачи младшего байта верхнего значения давления эталона (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Pm_low)) >> 8));	 // вызов функции передачи старшего байта нижнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(Pm_low));						 // вызов функции передачи младшего байта нижнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(((uint16_t)(Pm_high)) >> 8));	 // вызов функции передачи старшего байта верхнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
				// 			USART_send_byte((uint8_t)(Pm_high));					 // вызов функции передачи младшего байта верхнего значения давления метеоблока (в десятых долях мм ртутного столба, uint16_t)
				// 			break;

				// 		case 0x04:							// если байт соответствует чтению одного цикла выборки времени импульсов анемометра
				// 			for (uint8_t k = 0; k < 4; k++) // цикл по каналам с 1-го по 4-й
				// 			{
				// 				for (uint8_t j = 0; j < N_operativ; j++) // цикл по импульсам с 0-го по (N_operativ-1)
				// 				{
				// 					USART_send_byte((uint8_t)(Mas_timer_operativ[k][j] >> 8)); // вызов функции передачи старшего байта выборки времени импульса анемометра (в тактах микроконтроллера, uint16_t)
				// 					USART_send_byte((uint8_t)(Mas_timer_operativ[k][j]));	   // вызов функции передачи младшего байта выборки времени импульса анемометра (в тактах микроконтроллера, uint16_t)
				// 				}
				// 			}
				// 			break;

				// 		case 0x05:							// если байт соответствует чтению одного цикла выборки амплитуд импульсов анемометра
				// 			for (uint8_t k = 0; k < 4; k++) // цикл по каналам с 1-го по 4-й
				// 			{
				// 				for (uint8_t j = 0; j < N_operativ; j++) // цикл по импульсам с 0-го по (N_operativ-1)
				// 				{
				// 					USART_send_byte((uint8_t)(Mas_amplitude_operativ[k][j])); // вызов функции передачи байта выборки амплитуды импульса анемометра в 8-ми разрядном коде (uint8_t)
				// 				}
				// 			}
				// 			break;
				// 		}
				// 	}
				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x46

				// case 0x47:							 // если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x47
				// 	for (uint8_t i = 0; i < 12; i++) // цикл от 0 по 11
				// 	{
				// 		USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
				// 	}

				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x47 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}

				// 	else // иначе
				// 	{

				// 		temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Tst_low
				// 		eeprom_write_word((uint16_t *)60, temp_C);							 // запись в eeprom по адресу 60 значения Tst_low
				// 		Tst_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Tst_high
				// 		eeprom_write_word((uint16_t *)62, temp_C);							 // запись в eeprom по адресу 62 значения Tst_high
				// 		Tst_high = (double)(temp_C);										 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Tm_low
				// 		eeprom_write_word((uint16_t *)64, temp_C);							 // запись в eeprom по адресу 64 значения Tm_low
				// 		Tm_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Tm_high
				// 		eeprom_write_word((uint16_t *)66, temp_C);							  // запись в eeprom по адресу 66 значения Tm_high
				// 		Tm_high = (double)(temp_C);											  // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[11])) << 8) + (int16_t)(Mas_crc16[12]); // восстановление Th_low
				// 		eeprom_write_word((uint16_t *)68, temp_C);							   // запись в eeprom по адресу 68 значения Th_low
				// 		Th_low = (double)(temp_C);											   // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[13])) << 8) + (int16_t)(Mas_crc16[14]); // восстановление Th_high
				// 		eeprom_write_word((uint16_t *)70, temp_C);							   // запись в eeprom по адресу 70 значения Th_high
				// 		Th_high = (double)(temp_C);											   // приведение к типу double

				// 		eeprom_write_byte((uint8_t *)3, 1); // запись в eeprom по адресу 3 статуса калибровки температуры метеоблока
				// 		func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x47);			// вызов функции передачи байта кода функции модуля USART
				// 	}

				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x47

				// case 0x48:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x48
				// 	for (uint8_t i = 0; i < 4; i++) // цикл от 0 по 3
				// 	{
				// 		USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
				// 	}

				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x48 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}

				// 	else // иначе
				// 	{
				// 		Th_on = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Th_on
				// 		if (Th_on < 400)													// если значение Th_on меньше 40 градусов Цельсия
				// 		{
				// 			eeprom_write_word((uint16_t *)72, Th_on); // запись в eeprom по адресу 72 значения Th_on
				// 			eeprom_write_byte((uint8_t *)4, 1);		  // запись в eeprom по адресу 4 статуса температуры подогрева и серийного номера метеоблока
				// 			func_eeprom_read();						  // вызов функции чтения из eeprom данных калибровки
				// 		}
				// 		serial_number = (((uint16_t)(Mas_crc16[5])) << 8) + (uint16_t)(Mas_crc16[6]); // восстановление серийного номера метеоблока
				// 		eeprom_write_word((uint16_t *)102, serial_number);							  // запись в eeprom по адресу 102 значения serial_number

				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x48);			// вызов функции передачи байта кода функции модуля USART
				// 	}

				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x48

				// case 0x49:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x49
				// 	for (uint8_t i = 0; i < 8; i++) // цикл от 0 по 7
				// 	{
				// 		USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
				// 	}

				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x49 + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}

				// 	else // иначе
				// 	{
				// 		temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Hst_low
				// 		eeprom_write_word((uint16_t *)80, temp_C);							 // запись в eeprom по адресу 80 значения Hst_low
				// 		Hst_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Hst_high
				// 		eeprom_write_word((uint16_t *)82, temp_C);							 // запись в eeprom по адресу 82 значения Hst_high
				// 		Hst_high = (double)(temp_C);										 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Hm_low
				// 		eeprom_write_word((uint16_t *)84, temp_C);							 // запись в eeprom по адресу 84 значения Hm_low
				// 		Hm_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Hm_high
				// 		eeprom_write_word((uint16_t *)86, temp_C);							  // запись в eeprom по адресу 86 значения Hm_high
				// 		Hm_high = (double)(temp_C);											  // приведение к типу double

				// 		eeprom_write_byte((uint8_t *)5, 1); // запись в eeprom по адресу 5 статуса калибровки влажности метеоблока
				// 		func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x49);			// вызов функции передачи байта кода функции модуля USART
				// 	}

				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x49

				// case 0x4A:							// если байт кода функции соответствует команде записи служебных данных-----------------------------------------------------------начало функции 0x4A
				// 	for (uint8_t i = 0; i < 8; i++) // цикл от 0 по 7
				// 	{
				// 		USART_get_byte(); // считывание из приёмного буфера модуля USART байта данных
				// 	}

				// 	func_compare_crc16(); // вызов функции определения правильности принятого crc16

				// 	if (Status_error_USART != 0) // если статус ошибки модуля USART не равен "0" (присутствует ошибка)
				// 	{
				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x4A + 0x80);	// вызов функции передачи модифицированного байта кода функции модуля USART
				// 	}

				// 	else // иначе
				// 	{
				// 		temp_C = (((int16_t)(Mas_crc16[3])) << 8) + (int16_t)(Mas_crc16[4]); // восстановление Pst_low
				// 		eeprom_write_word((uint16_t *)90, temp_C);							 // запись в eeprom по адресу 90 значения Pst_low
				// 		Pst_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[5])) << 8) + (int16_t)(Mas_crc16[6]); // восстановление Pst_high
				// 		eeprom_write_word((uint16_t *)92, temp_C);							 // запись в eeprom по адресу 92 значения Pst_high
				// 		Pst_high = (double)(temp_C);										 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[7])) << 8) + (int16_t)(Mas_crc16[8]); // восстановление Pm_low
				// 		eeprom_write_word((uint16_t *)94, temp_C);							 // запись в eeprom по адресу 94 значения Pm_low
				// 		Pm_low = (double)(temp_C);											 // приведение к типу double

				// 		temp_C = (((int16_t)(Mas_crc16[9])) << 8) + (int16_t)(Mas_crc16[10]); // восстановление Pm_high
				// 		eeprom_write_word((uint16_t *)96, temp_C);							  // запись в eeprom по адресу 96 значения Pm_high
				// 		Pm_high = (double)(temp_C);											  // приведение к типу double

				// 		eeprom_write_byte((uint8_t *)6, 1); // запись в eeprom по адресу 6 статуса калибровки давления метеоблока
				// 		func_eeprom_read();					// вызов функции чтения из eeprom данных калибровки

				// 		USART_mode_transceiver(1);		// функция управления приёмопередатчиком модуля USART ("1" - режим передатчика)
				// 		USART_send_byte(USART_address); // вызов функции передачи байта адреса метеоблока М1 модуля USART
				// 		USART_send_byte(0x4A);			// вызов функции передачи байта кода функции модуля USART
				// 	}

				// 	func_USART_send_crc16();   // вызов функции передачи crc16 модуля USART
				// 	Status_error_USART = 0;	   // обнуление переменной статуса ошибки модуля USART
				// 	USART_mode_transceiver(0); // функция управления приёмопередатчиком модуля USART ("0" - режим приёмника)
				// 	break;					   // выход из байта функции 0x4A

			case 0x4B:
				USART_get_byte();
				USART_get_byte();
				USART_get_byte();
				USART_get_byte();
				USART_get_byte();
				USART_mode_transceiver(1);
				if (Status_error_USART != 0)
				{
					USART_send_byte(USART_address);
					USART_send_byte(0x4B + 0x80);
				}
				else
				{
					Mas_basedPD[0] = Mas_crc16[3] == 0 ? Mas_basedPD[0] : Mas_crc16[3];
					Mas_basedPD[1] = Mas_crc16[4] == 0 ? Mas_basedPD[1] : Mas_crc16[4];
					Mas_basedPD[2] = Mas_crc16[5] == 0 ? Mas_basedPD[2] : Mas_crc16[5];
					Mas_basedPD[3] = Mas_crc16[6] == 0 ? Mas_basedPD[3] : Mas_crc16[6];
					ADC_porog = Mas_crc16[7] == 0 ? ADC_porog : Mas_crc16[7];
					USART_send_byte(USART_address);
					USART_send_byte(0x4B);
				}
				Status_error_USART = 0;
				USART_mode_transceiver(0);
				break;
			} // конец перечисления байтов функций
		}
		else
		{
			if (Mas_crc16[counter_buffer] == 0x00) // если принятый байт равен "0x00"
			{
				USART_get_byte();					   // считывание из приёмного буфера модуля USART байта кода функции
				if (Mas_crc16[counter_buffer] == 0x42) // если принятый байт равен "0x42"
				{
					USART_get_byte();	  // считывание из приёмного буфера модуля USART байта кода функции
					func_compare_crc16(); // вызов функции определения правильности принятого crc16

					if (Status_error_USART == 0) // если статус ошибки модуля USART равен "0" (нет ошибок)
					{
						func_DS18B20_temperature_meas_start(); // вызов функции старта измерения температуры датчика DS18B20
						twi_master_BME280_start_meas();		   // вызов функции старта измерения BME280
						func_skorost(Mas_crc16[3]);			   // вызов функции скорости ветра в дм/с
						twi_BME280_read_TPH();				   // вызов функции мастер-приёмник модуля twi для чтения данных температуры, давления и влажности BME280
						func_compensate_TPH();				   // вызов функции вычисления компенсированных значений температуры, давления и влажности
						func_DS18B20_temperature_meas_read();  // вызов функции чтения измеренной температуры датчика DS18B20
					}
					Status_error_DS18B20 = 0;	// обнуление статуса ошибки связи с датчиком DS18B20
					Status_error_BME280 = 0;	// обнуление статуса ошибки связи с модулем BME280
					Status_error_anemometr = 0; // обнуление статуса ошибки связи с анемометром
					Status_error_USART = 0;		// обнуление переменной статуса ошибки модуля USART
				}
			}
		}
		// interrupt_ON; //глобальное разрешение прерываний
		// interrupt_ON(); //вызов функции разрешения прерываний
		USARTC1_CTRLA = USART_RXCINTLVL_LO_gc; // установка низкого уровня прерываний по завершению приёма
		RTC_ON;								   // разрешение прерывания счетчика реального времени RTC по совпадению с низким уровнем приоритета
											   // Timer_heating_control_ON; //включение таймера-счётчика управления подогревом
	}
	//---------------------------------------------------------------------------------------------------------------------------конец обработки прерывания модуля USART по завершению приёма данных
	//---------------------------------------------------------------------------------------------------------------------------- Прерывания (конец)
